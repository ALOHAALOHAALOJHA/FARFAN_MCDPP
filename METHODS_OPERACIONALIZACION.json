{
  "AdaptivePriorCalculator._add_ood_noise": {
    "file": "derek_beach.py",
    "questions": [
      "Q025"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "evidence_dict con scores",
      "formato_salida": "evidence_dict con ruido gaussiano N(0, 0.05) añadido a todos los scores",
      "calculo": "score + ruido_gaussiano, clip [0.0, 1.0]",
      "parametros": "evidence_dict: dict[str, Any]",
      "parametros_configurables": [
        {
          "nombre": "evidence_dict",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence_dict: dict[str, Any])",
      "descripcion": "Genera set OOD con ruido semántico y tablas malformadas"
    }
  },
  "AdaptivePriorCalculator._adjust_domain_weights": {
    "file": "derek_beach.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "dict con scores numéricos por dominio {semantic: float, temporal: float, financial: float, structural: float}",
      "formato_salida": "dict con pesos ajustados normalizados que suman 1.0",
      "calculo": "redistribuye peso de dominios faltantes (score≤0) a dominios activos",
      "parametros": "domain_scores: dict[str, float]",
      "parametros_configurables": [
        {
          "nombre": "domain_scores",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(domain_scores: dict[str, float])",
      "descripcion": "Ajusta pesos si falta dominio: baja a 0 y reparte"
    }
  },
  "AdaptivePriorCalculator._perturb_evidence": {
    "file": "derek_beach.py",
    "questions": [
      "Q023"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "evidence_dict original, dominio a perturbar, porcentaje de perturbación",
      "formato_salida": "copia de evidence_dict con score del dominio multiplicado por (1+perturbation)",
      "calculo": "multiplica score del dominio específico, clip a máximo 1.0",
      "parametros": "evidence_dict: dict, domain: str, perturbation: float",
      "parametros_configurables": [
        {
          "nombre": "evidence_dict",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "domain",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "perturbation",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence_dict: dict[str, Any], domain: str, perturbation: float)",
      "descripcion": "Perturba un dominio específico"
    }
  },
  "AdaptivePriorCalculator.calculate_likelihood_adaptativo": {
    "file": "derek_beach.py",
    "questions": [
      "Q010",
      "Q012"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "dict con scores numéricos por dominio {semantic: {score: 0.0-1.0}, temporal: {score: 0.0-1.0}, financial: {score: 0.0-1.0}, structural: {score: 0.0-1.0}}",
      "formato_salida": "probabilidad p_mechanism [0-1], Bayes Factor usado, pesos por dominio",
      "calculo": "promedio_ponderado de scores × BF × logit inverso → probabilidad calibrada",
      "parametros": "evidence_dict: dict[str, Any], test_type: str='hoop' (straw|hoop|smoking|doubly)",
      "parametros_configurables": [
        {
          "nombre": "evidence_dict",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "test_type",
          "anotacion": "str",
          "default": "'hoop'",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence_dict: dict[str, Any], test_type: str='hoop')",
      "descripcion": "PROMPT I-1: Calcula likelihood adaptativo con BF y dominios"
    }
  },
  "AdaptivePriorCalculator.generate_traceability_record": {
    "file": "derek_beach.py",
    "questions": [
      "Q011",
      "Q013",
      "Q030"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "MIXTO (cuantitativo + trazabilidad)",
      "formato_entrada": "evidence_dict, test_type, result previo, semilla fija",
      "formato_salida": "registro con hash_config, hash_result, evidence_trace (source, line_span, snippet), trace_completeness",
      "calculo": "SHA-256 de config + result para reproducibilidad, trace_completeness = factores_en_trace / total_factores",
      "parametros": "evidence_dict: dict, test_type: str, result: dict, seed: int=42",
      "parametros_configurables": [
        {
          "nombre": "evidence_dict",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "test_type",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "result",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "seed",
          "anotacion": "int",
          "default": "42",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence_dict: dict[str, Any], test_type: str, result: dict[str, Any], seed: int=42)",
      "descripcion": "PROMPT I-3: Trazabilidad y reproducibilidad"
    }
  },
  "AdaptivePriorCalculator.sensitivity_analysis": {
    "file": "derek_beach.py",
    "questions": [
      "Q009",
      "Q018",
      "Q024"
    ],
    "dimensions": [
      "DIM02",
      "DIM04",
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "evidence_dict con scores, test_type, perturbación %",
      "formato_salida": "top-3 componentes más influyentes, delta_p_sensitivity, OOD_drop, si es frágil",
      "calculo": "perturba cada dominio ±10%, mide cambio en p_mechanism, ablaciones single-domain, inyecta ruido OOD",
      "parametros": "evidence_dict: dict, test_type: str='hoop', perturbation: float=0.10",
      "criterios_calidad": "max_sensitivity ≤0.15, sign_concordance ≥2/3, OOD_drop ≤0.10",
      "parametros_configurables": [
        {
          "nombre": "evidence_dict",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "test_type",
          "anotacion": "str",
          "default": "'hoop'",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "perturbation",
          "anotacion": "float",
          "default": "0.1",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence_dict: dict[str, Any], test_type: str='hoop', perturbation: float=0.1)",
      "descripcion": "PROMPT I-2: Sensibilidad, OOD y ablation evidencial"
    }
  },
  "AdaptivePriorCalculator.validate_quality_criteria": {
    "file": "derek_beach.py",
    "questions": [
      "Q020",
      "Q025",
      "Q028"
    ],
    "dimensions": [
      "DIM04",
      "DIM05",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "lista de samples de validación con {evidence, actual_label, test_type}",
      "formato_salida": "Brier Score, ACE, CI95% coverage, monotonicity_violations, quality_grade",
      "calculo": "Brier = mean((pred-actual)²), ACE = error calibración promedio en 10 bins, bootstrap CI95%",
      "parametros": "validation_samples: list[dict[str, Any]]",
      "criterios_calidad": "Brier ≤0.20, ACE ∈[-0.02,0.02], CI95% ∈[92%,98%], monotonicity=0 violaciones",
      "parametros_configurables": [
        {
          "nombre": "validation_samples",
          "anotacion": "list[dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(validation_samples: list[dict[str, Any]])",
      "descripcion": "Valida criterios de calidad en conjunto de validación sintética"
    }
  },
  "AdvancedDAGValidator._calculate_bayesian_posterior": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "likelihood",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "prior",
          "anotacion": "float",
          "default": "0.5",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(likelihood: float, prior: float=0.5)",
      "descripcion": "Calcula la probabilidad posterior Bayesiana simple.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(likelihood: float, prior: float=0.5)"
    }
  },
  "AdvancedDAGValidator._calculate_confidence_interval": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "s",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "n",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "conf",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(s: int, n: int, conf: float)",
      "descripcion": "Calcula el intervalo de confianza de Wilson.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(s: int, n: int, conf: float)"
    }
  },
  "AdvancedDAGValidator._calculate_node_importance": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q029"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Calcula una métrica de importancia para cada nodo.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "AdvancedDAGValidator._calculate_statistical_power": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q018"
    ],
    "dimensions": [
      "DIM03",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "s",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "n",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "alpha",
          "anotacion": "float",
          "default": "0.05",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(s: int, n: int, alpha: float=0.05)",
      "descripcion": "Calcula el poder estadístico a posteriori.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(s: int, n: int, alpha: float=0.05)"
    }
  },
  "AdvancedDAGValidator._create_empty_result": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "plan_name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "seed",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "timestamp",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(plan_name: str, seed: int, timestamp: str)",
      "descripcion": "Crea un resultado vacío para grafos sin nodos.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(plan_name: str, seed: int, timestamp: str)"
    }
  },
  "AdvancedDAGValidator._generate_subgraph": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Genera un subgrafo aleatorio del grafo principal.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "AdvancedDAGValidator._get_node_validator": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "schema_path",
          "anotacion": "Path | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(schema_path: Path | None=None)",
      "descripcion": "Obtiene (y cachea) el validador JSON Schema para nodos avanzados.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(schema_path: Path | None=None)"
    }
  },
  "AdvancedDAGValidator._initialize_rng": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "plan_name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "salt",
          "anotacion": "str",
          "default": "''",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(plan_name: str, salt: str='')",
      "descripcion": "Inicializa el generador de números aleatorios con una semilla determinista.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(plan_name: str, salt: str='')"
    }
  },
  "AdvancedDAGValidator._is_acyclic": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, AdvancedGraphNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, AdvancedGraphNode])",
      "descripcion": "Detección de ciclos mediante el algoritmo de Kahn (ordenación topológica).",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, AdvancedGraphNode])"
    }
  },
  "AdvancedDAGValidator._perform_sensitivity_analysis_internal": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q017"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "plan_name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "base_p_value",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "iterations",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(plan_name: str, base_p_value: float, iterations: int)",
      "descripcion": "Análisis de sensibilidad interno optimizado para evitar cálculos redundantes.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(plan_name: str, base_p_value: float, iterations: int)"
    }
  },
  "AdvancedDAGValidator.add_edge": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "from_node",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "to_node",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "weight",
          "anotacion": "float",
          "default": "1.0",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(from_node: str, to_node: str, weight: float=1.0)",
      "descripcion": "Agrega una arista dirigida con peso opcional.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(from_node: str, to_node: str, weight: float=1.0)"
    }
  },
  "AdvancedDAGValidator.add_node": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dependencies",
          "anotacion": "set[str] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "role",
          "anotacion": "str",
          "default": "'variable'",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "metadata",
          "anotacion": "dict[str, Any] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(name: str, dependencies: set[str] | None=None, role: str='variable', metadata: dict[str, Any] | None=None)",
      "descripcion": "Agrega un nodo enriquecido al grafo.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(name: str, dependencies: set[str] | None=None, role: str='variable', metadata: dict[str, Any] | None=None)"
    }
  },
  "AdvancedDAGValidator.calculate_acyclicity_pvalue": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q028"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (estadístico)",
      "formato_entrada": "graph: nx.DiGraph",
      "formato_salida": "p-value para test de aciclicidad",
      "calculo": "test estadístico de estructura DAG, bootstrapped confidence",
      "parametros": "graph: nx.DiGraph",
      "parametros_configurables": [
        {
          "nombre": "plan_name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "iterations",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(plan_name: str, iterations: int)",
      "descripcion": "Cálculo avanzado de p-value con un marco estadístico completo."
    }
  },
  "AdvancedDAGValidator.export_nodes": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q026"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "validate",
          "anotacion": "bool",
          "default": "False",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "schema_path",
          "anotacion": "Path | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(validate: bool=False, schema_path: Path | None=None)",
      "descripcion": "Serializa los nodos del grafo y opcionalmente valida contra JSON Schema.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(validate: bool=False, schema_path: Path | None=None)"
    }
  },
  "AdvancedDAGValidator.get_graph_stats": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Obtiene estadísticas estructurales del grafo.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "BayesFactorTable.get_bayes_factor": {
    "file": "derek_beach.py",
    "questions": [
      "Q017",
      "Q029"
    ],
    "dimensions": [
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "test_type: string",
      "formato_salida": "Bayes Factor numérico (media del rango para ese test type)",
      "calculo": "lookup en tabla: straw=[1,2], hoop=[2,5], smoking=[5,15], doubly=[15,50] → promedio",
      "parametros": "test_type: str",
      "parametros_configurables": [
        {
          "nombre": "test_type",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(test_type: str)",
      "descripcion": "Obtiene BF medio para tipo de test"
    }
  },
  "BayesianConfidenceCalculator.calculate_posterior": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "evidence_strength",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observations",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "domain_weight",
          "anotacion": "float",
          "default": "1.0",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence_strength: float, observations: int, domain_weight: float=1.0)",
      "descripcion": "Calculate posterior probability using Bayesian inference.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(evidence_strength: float, observations: int, domain_weight: float=1.0)"
    }
  },
  "BayesianCounterfactualAuditor._create_default_equations": {
    "file": "derek_beach.py",
    "questions": [
      "Q008"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: nx.DiGraph)",
      "descripcion": "Crea ecuaciones estructurales lineales por defecto",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: nx.DiGraph)"
    }
  },
  "BayesianCounterfactualAuditor._evaluate_counterfactual": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "intervention",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "evidence",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(target: str, intervention: dict[str, float], evidence: dict[str, float])",
      "descripcion": "Evalúa P(target | do(intervention), evidence) con DAG mutilado",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(target: str, intervention: dict[str, float], evidence: dict[str, float])"
    }
  },
  "BayesianCounterfactualAuditor._evaluate_factual": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "evidence",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(target: str, evidence: dict[str, float])",
      "descripcion": "Evalúa P(target | evidence) propagando hacia adelante en DAG",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(target: str, evidence: dict[str, float])"
    }
  },
  "BayesianCounterfactualAuditor._test_effect_stability": {
    "file": "derek_beach.py",
    "questions": [
      "Q002",
      "Q024",
      "Q027"
    ],
    "dimensions": [
      "DIM01",
      "DIM05",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "intervention",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "evidence",
          "anotacion": "dict[str, float] | None",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "n_perturbations",
          "anotacion": "int",
          "default": "5",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(intervention: dict[str, float], target: str, evidence: dict[str, float] | None, n_perturbations: int=5)",
      "descripcion": "Testa estabilidad al variar priors/ecuaciones ±10%",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(intervention: dict[str, float], target: str, evidence: dict[str, float] | None, n_perturbations: int=5)"
    }
  },
  "BayesianCounterfactualAuditor.aggregate_risk_and_prioritize": {
    "file": "derek_beach.py",
    "questions": [
      "Q003",
      "Q009",
      "Q019",
      "Q022"
    ],
    "dimensions": [
      "DIM01",
      "DIM02",
      "DIM04",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "omission_score",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "insufficiency_score",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "unnecessity_score",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_effect",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "feasibility",
          "anotacion": "float",
          "default": "0.8",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "cost",
          "anotacion": "float",
          "default": "1.0",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(omission_score: float, insufficiency_score: float, unnecessity_score: float, causal_effect: float, feasibility: float=0.8, cost: float=1.0)",
      "descripcion": "PROMPT III-2: Riesgo sistémico y priorización con incertidumbre",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(omission_score: float, insufficiency_score: float, unnecessity_score: float, causal_effect: float, feasibility: float=0.8, cost: float=1.0)"
    }
  },
  "BayesianCounterfactualAuditor.construct_scm": {
    "file": "derek_beach.py",
    "questions": [
      "Q008",
      "Q017",
      "Q021"
    ],
    "dimensions": [
      "DIM02",
      "DIM04",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "structural_equations",
          "anotacion": "dict[str, callable] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: nx.DiGraph, structural_equations: dict[str, callable] | None=None)",
      "descripcion": "PROMPT III-1: Construcción de SCM",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: nx.DiGraph, structural_equations: dict[str, callable] | None=None)"
    }
  },
  "BayesianCounterfactualAuditor.counterfactual_query": {
    "file": "derek_beach.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "intervention",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "evidence",
          "anotacion": "dict[str, float] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(intervention: dict[str, float], target: str, evidence: dict[str, float] | None=None)",
      "descripcion": "PROMPT III-1: Queries gemelas (omission, sufficiency, necessity)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(intervention: dict[str, float], target: str, evidence: dict[str, float] | None=None)"
    }
  },
  "BayesianCounterfactualAuditor.refutation_and_sanity_checks": {
    "file": "derek_beach.py",
    "questions": [
      "Q009",
      "Q015",
      "Q024"
    ],
    "dimensions": [
      "DIM02",
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "treatment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "confounders",
          "anotacion": "list[str] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: nx.DiGraph, target: str, treatment: str, confounders: list[str] | None=None)",
      "descripcion": "PROMPT III-3: Refutación, negativos y cordura do(.)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: nx.DiGraph, target: str, treatment: str, confounders: list[str] | None=None)"
    }
  },
  "BayesianMechanismInference._aggregate_bayesian_confidence": {
    "file": "derek_beach.py",
    "questions": [
      "Q018",
      "Q022"
    ],
    "dimensions": [
      "DIM04",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "confidences",
          "anotacion": "list[float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(confidences: list[float])",
      "descripcion": "Aggregate multiple Bayesian confidence values.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(confidences: list[float])"
    }
  },
  "BayesianMechanismInference._calculate_coherence_factor": {
    "file": "derek_beach.py",
    "questions": [
      "Q010",
      "Q025",
      "Q027"
    ],
    "dimensions": [
      "DIM02",
      "DIM05",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "node",
          "anotacion": "MetaNode",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "all_nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(node: MetaNode, observations: dict[str, Any], all_nodes: dict[str, MetaNode])",
      "descripcion": "Calculate mechanism coherence score",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(node: MetaNode, observations: dict[str, Any], all_nodes: dict[str, MetaNode])"
    }
  },
  "BayesianMechanismInference._detect_gaps": {
    "file": "derek_beach.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "node",
          "anotacion": "MetaNode",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "uncertainty",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(node: MetaNode, observations: dict[str, Any], uncertainty: dict[str, float])",
      "descripcion": "Detect documentation gaps based on uncertainty",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(node: MetaNode, observations: dict[str, Any], uncertainty: dict[str, float])"
    }
  },
  "BayesianMechanismInference._generate_necessity_remediation": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "node_id",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "missing_components",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(node_id: str, missing_components: list[str])",
      "descripcion": "Generate remediation text for failed necessity test",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(node_id: str, missing_components: list[str])"
    }
  },
  "BayesianMechanismInference._infer_activity_sequence": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "mechanism_type_posterior",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(observations: dict[str, Any], mechanism_type_posterior: dict[str, float])",
      "descripcion": "Infer activity sequence parameters",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(observations: dict[str, Any], mechanism_type_posterior: dict[str, float])"
    }
  },
  "BayesianMechanismInference._infer_mechanism_type": {
    "file": "derek_beach.py",
    "questions": [
      "Q007"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(observations: dict[str, Any])",
      "descripcion": "Infer mechanism type using Bayesian updating",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(observations: dict[str, Any])"
    }
  },
  "BayesianMechanismInference._infer_single_mechanism": {
    "file": "derek_beach.py",
    "questions": [
      "Q007"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "node",
          "anotacion": "MetaNode",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "all_nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(node: MetaNode, text: str, all_nodes: dict[str, MetaNode])",
      "descripcion": "Infer mechanism for a single product node",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(node: MetaNode, text: str, all_nodes: dict[str, MetaNode])"
    }
  },
  "BayesianMechanismInference._log_refactored_components": {
    "file": "derek_beach.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Log status of refactored Bayesian components (F1.2)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "BayesianMechanismInference._quantify_uncertainty": {
    "file": "derek_beach.py",
    "questions": [
      "Q023"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "mechanism_type_posterior",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "sequence_posterior",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "coherence_score",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(mechanism_type_posterior: dict[str, float], sequence_posterior: dict[str, Any], coherence_score: float)",
      "descripcion": "Quantify epistemic uncertainty",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(mechanism_type_posterior: dict[str, float], sequence_posterior: dict[str, Any], coherence_score: float)"
    }
  },
  "BayesianMechanismInference._test_necessity": {
    "file": "derek_beach.py",
    "questions": [
      "Q007",
      "Q012",
      "Q014",
      "Q027"
    ],
    "dimensions": [
      "DIM02",
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "mechanism: dict, evidence: dict",
      "formato_salida": "float [0-1] score de necesidad",
      "calculo": "verifica si componente está presente en TODOS los casos positivos, score = proporción presente",
      "parametros": "mechanism: dict, evidence: dict",
      "parametros_configurables": [
        {
          "nombre": "node",
          "anotacion": "MetaNode",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(node: MetaNode, observations: dict[str, Any])",
      "descripcion": "AUDIT POINT 2.2: Mechanism Necessity Hoop Test"
    }
  },
  "BayesianMechanismInference._test_sufficiency": {
    "file": "derek_beach.py",
    "questions": [
      "Q007",
      "Q012",
      "Q027"
    ],
    "dimensions": [
      "DIM02",
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "mechanism: dict, evidence: dict",
      "formato_salida": "float [0-1] score de suficiencia",
      "calculo": "verifica si presencia de componente SIEMPRE produce outcome, score = proporción éxito dado presente",
      "parametros": "mechanism: dict, evidence: dict",
      "parametros_configurables": [
        {
          "nombre": "node",
          "anotacion": "MetaNode",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(node: MetaNode, observations: dict[str, Any])",
      "descripcion": "Test if mechanism is sufficient to produce the outcome"
    }
  },
  "BayesianMechanismInference.infer_mechanisms": {
    "file": "derek_beach.py",
    "questions": [
      "Q007",
      "Q015"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (posterior bayesiano)",
      "formato_entrada": "text: str, policy_area: str|None",
      "formato_salida": "lista de mecanismos inferidos con type, probability, necessity/sufficiency scores",
      "calculo": "extrae evidencia por tipo mecanismo, aplica tests Beach, actualiza posterior",
      "parametros": "text: str, policy_area: str|None=None",
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode], text: str)",
      "descripcion": "Infer latent causal mechanisms using hierarchical Bayesian modeling"
    }
  },
  "BayesianNumericalAnalyzer.compare_policies": {
    "file": "embedding_policy.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "policy_a_values",
          "anotacion": "list[float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_b_values",
          "anotacion": "list[float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(policy_a_values: list[float], policy_b_values: list[float])",
      "descripcion": "Bayesian comparison of two policy metrics.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(policy_a_values: list[float], policy_b_values: list[float])"
    }
  },
  "BayesianNumericalAnalyzer.evaluate_policy_metric": {
    "file": "embedding_policy.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "observed_values",
          "anotacion": "list[float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "n_posterior_samples",
          "anotacion": "int",
          "default": "10000",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": "Any",
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(observed_values: list[float], n_posterior_samples: int=10000, **kwargs)",
      "descripcion": "Bayesian evaluation of policy metric with uncertainty quantification.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(observed_values: list[float], n_posterior_samples: int=10000, **kwargs)"
    }
  },
  "BeachEvidentialTest.apply_test_logic": {
    "file": "derek_beach.py",
    "questions": [
      "Q011",
      "Q027"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO + CUALITATIVO",
      "formato_entrada": "test_type, evidence_found (bool), prior probability, bayes_factor",
      "formato_salida": "(posterior_confidence: float, interpretation: str)",
      "calculo": "hoop fail→0.01, smoking pass→prior×max(BF,10), doubly→0.99/0.01, straw→ajuste marginal",
      "parametros": "test_type: TestType, evidence_found: bool, prior: float, bayes_factor: float",
      "parametros_configurables": [
        {
          "nombre": "test_type",
          "anotacion": "TestType",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "evidence_found",
          "anotacion": "bool",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "prior",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "bayes_factor",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(test_type: TestType, evidence_found: bool, prior: float, bayes_factor: float)",
      "descripcion": "Apply Beach test-specific logic to Bayesian updating."
    }
  },
  "BeachEvidentialTest.classify_test": {
    "file": "derek_beach.py",
    "questions": [
      "Q007"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO (categoría)",
      "formato_entrada": "necessity: float [0-1], sufficiency: float [0-1]",
      "formato_salida": "TestType literal: 'hoop_test'|'smoking_gun'|'doubly_decisive'|'straw_in_wind'",
      "calculo": "umbral 0.7: high_N + high_S → doubly, high_N only → hoop, high_S only → smoking, else straw",
      "parametros": "necessity: float, sufficiency: float",
      "parametros_configurables": [
        {
          "nombre": "necessity",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "sufficiency",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(necessity: float, sufficiency: float)",
      "descripcion": "Classify evidential test type based on necessity and sufficiency."
    }
  },
  "CDAFFramework._extract_feedback_from_audit": {
    "file": "derek_beach.py",
    "questions": [
      "Q029"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "inferred_mechanisms",
          "anotacion": "dict[str, dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "counterfactual_audit",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "audit_results",
          "anotacion": "dict[str, AuditResult]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(inferred_mechanisms: dict[str, dict[str, Any]], counterfactual_audit: dict[str, Any], audit_results: dict[str, AuditResult])",
      "descripcion": "Extract feedback data from audit results for self-reflective prior updating",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(inferred_mechanisms: dict[str, dict[str, Any]], counterfactual_audit: dict[str, Any], audit_results: dict[str, AuditResult])"
    }
  },
  "CDAFFramework._generate_dnp_report": {
    "file": "derek_beach.py",
    "questions": [
      "Q020"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dnp_results",
          "anotacion": "list[dict]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_code",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dnp_results: list[dict], policy_code: str)",
      "descripcion": "Generate comprehensive DNP compliance report",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dnp_results: list[dict], policy_code: str)"
    }
  },
  "CDAFFramework._validate_dnp_compliance": {
    "file": "derek_beach.py",
    "questions": [
      "Q020"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_code",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode], graph: nx.DiGraph, policy_code: str)",
      "descripcion": "Validate DNP compliance for all nodes/projects",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, MetaNode], graph: nx.DiGraph, policy_code: str)"
    }
  },
  "CausalExtractor._assess_financial_consistency": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "source: str, target: str",
      "formato_salida": "float [0-1] consistencia financiera",
      "calculo": "verifica si hay asignación financiera en ambos nodos, penaliza si falta",
      "parametros": "source: str, target: str",
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str)",
      "descripcion": "Assess financial alignment between connected nodes"
    }
  },
  "CausalExtractor._assess_temporal_coherence": {
    "file": "derek_beach.py",
    "questions": [
      "Q005",
      "Q021",
      "Q030"
    ],
    "dimensions": [
      "DIM01",
      "DIM05",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "source: str, target: str",
      "formato_salida": "float [0-1] coherencia temporal",
      "calculo": "secuencia verbos: diagnosticar(1)→planificar(2)→ejecutar(3)→evaluar(4), in_seq=0.85, same=0.60, reverse=0.30",
      "parametros": "source: str, target: str",
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str)",
      "descripcion": "Assess temporal coherence based on verb sequences"
    }
  },
  "CausalExtractor._build_type_hierarchy": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Build hierarchy based on goal types",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "CausalExtractor._calculate_composite_likelihood": {
    "file": "derek_beach.py",
    "questions": [
      "Q008",
      "Q016"
    ],
    "dimensions": [
      "DIM02",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "evidence",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(evidence: dict[str, Any])",
      "descripcion": "Calculate composite likelihood from multiple evidence components",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(evidence: dict[str, Any])"
    }
  },
  "CausalExtractor._calculate_language_specificity": {
    "file": "derek_beach.py",
    "questions": [
      "Q016",
      "Q030"
    ],
    "dimensions": [
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO + PATRON",
      "formato_entrada": "keyword: str, policy_area: str|None, context: str|None",
      "formato_salida": "float [0-1] especificidad lingüística",
      "calculo": "base por tipo causal (strong=0.9, moderate=0.7, weak=0.5) + boost por vocabulario policy-specific (+0.15)",
      "parametros": "keyword: str, policy_area: str|None=None, context: str|None=None",
      "parametros_configurables": [
        {
          "nombre": "keyword",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_area",
          "anotacion": "str | None",
          "default": "None",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "context",
          "anotacion": "str | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(keyword: str, policy_area: str | None=None, context: str | None=None)",
      "descripcion": "Assess specificity of causal language (epistemic certainty)"
    }
  },
  "CausalExtractor._calculate_semantic_distance": {
    "file": "derek_beach.py",
    "questions": [
      "Q016",
      "Q023"
    ],
    "dimensions": [
      "DIM04",
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "source: str (node_id), target: str (node_id)",
      "formato_salida": "float [0-1] similaridad semántica",
      "calculo": "1 - cosine_distance(spaCy_vector_source, spaCy_vector_target)",
      "parametros": "source: str, target: str",
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str)",
      "descripcion": "Calculate semantic distance between nodes using spaCy embeddings"
    }
  },
  "CausalExtractor._calculate_textual_proximity": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str, text: str)",
      "descripcion": "Calculate how often node IDs appear together in text windows",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(source: str, target: str, text: str)"
    }
  },
  "CausalExtractor._calculate_type_transition_prior": {
    "file": "derek_beach.py",
    "questions": [
      "Q008",
      "Q015"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "source: str, target: str",
      "formato_salida": "float [0-1] prior de transición",
      "calculo": "lookup tabla: programa→producto=0.85, producto→resultado=0.80, resultado→impacto=0.75, reverso ×0.3",
      "parametros": "source: str, target: str",
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str)",
      "descripcion": "Calculate prior based on historical transition frequencies between goal types"
    }
  },
  "CausalExtractor._check_structural_violation": {
    "file": "derek_beach.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO (veto binario)",
      "formato_entrada": "source: str, target: str",
      "formato_salida": "None si válido, string describiendo violación si inválido",
      "calculo": "jerarquía programa(1)→producto(2)→resultado(3)→impacto(4), veto si reverse o skip>2 niveles",
      "parametros": "source: str, target: str",
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str)",
      "descripcion": "AUDIT POINT 2.1: Structural Veto (D6-Q2)"
    }
  },
  "CausalExtractor._classify_goal_type": {
    "file": "derek_beach.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Classify the type of a goal based on its text.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "CausalExtractor._extract_causal_links": {
    "file": "derek_beach.py",
    "questions": [
      "Q008"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (Bayesian posterior)",
      "formato_entrada": "text: string del documento",
      "formato_salida": "aristas en grafo con posterior_mean, posterior_std, kl_divergence, converged",
      "calculo": "Beta-Binomial conjugate prior, actualización incremental por evidencia, veto estructural ≤0.6",
      "parametros": "text: str (usa self.nodes internamente)",
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "AGUJA I: El Prior Informado Adaptativo"
    }
  },
  "CausalExtractor._extract_goals": {
    "file": "derek_beach.py",
    "questions": [
      "Q001",
      "Q016"
    ],
    "dimensions": [
      "DIM01",
      "DIM04"
    ],
    "operacionalizacion": {
      "tipo_valor": "PATRON (extracción regex)",
      "formato_entrada": "text: string del documento",
      "formato_salida": "list[MetaNode] con id, type (programa|producto|resultado|impacto), baseline, target",
      "calculo": "regex [MP][RIP]-\\d{3}, clasifica por prefijo, extrae contexto ±500 chars",
      "parametros": "text: str",
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Extract all goals from text"
    }
  },
  "CausalExtractor._initialize_prior": {
    "file": "derek_beach.py",
    "questions": [
      "Q008"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "source",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(source: str, target: str)",
      "descripcion": "Initialize prior distribution for causal link",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(source: str, target: str)"
    }
  },
  "CausalExtractor._parse_goal_context": {
    "file": "derek_beach.py",
    "questions": [
      "Q001",
      "Q016"
    ],
    "dimensions": [
      "DIM01",
      "DIM04"
    ],
    "operacionalizacion": {
      "tipo_valor": "PATRON + CUANTITATIVO",
      "formato_entrada": "goal_id: str, context: str (±500 chars alrededor)",
      "formato_salida": "MetaNode con type, baseline (1er número), target (2do número), responsible_entity",
      "calculo": "clasifica por prefijo (MP→producto, MR→resultado, MI→impacto), extrae números con regex, NER con spaCy",
      "parametros": "goal_id: str, context: str",
      "parametros_configurables": [
        {
          "nombre": "goal_id",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "context",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(goal_id: str, context: str)",
      "descripcion": "Parse goal context to extract structured information"
    }
  },
  "CausalExtractor.extract_causal_hierarchy": {
    "file": "derek_beach.py",
    "questions": [
      "Q007",
      "Q017",
      "Q026"
    ],
    "dimensions": [
      "DIM02",
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "ESTRUCTURAL (grafo)",
      "formato_entrada": "text: string completo del documento",
      "formato_salida": "nx.DiGraph con nodos (MetaNode) y aristas causales con posterior bayesiano",
      "calculo": "extrae metas (regex), infiere links causales con Bayesian updating, estructura jerárquica",
      "parametros": "text: str",
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Extract complete causal hierarchy from text"
    }
  },
  "CausalInferenceSetup._get_dynamics_pattern": {
    "file": "derek_beach.py",
    "questions": [
      "Q030"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dynamics_type",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dynamics_type: str)",
      "descripcion": "Get the pattern associated with a dynamics type.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dynamics_type: str)"
    }
  },
  "CausalInferenceSetup.assign_probative_value": {
    "file": "derek_beach.py",
    "questions": [
      "Q011"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode])",
      "descripcion": "Assign probative test types to nodes",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, MetaNode])"
    }
  },
  "CausalInferenceSetup.identify_failure_points": {
    "file": "derek_beach.py",
    "questions": [
      "Q005",
      "Q030"
    ],
    "dimensions": [
      "DIM01",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(graph: nx.DiGraph, text: str)",
      "descripcion": "Identify single points of failure in causal chain",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(graph: nx.DiGraph, text: str)"
    }
  },
  "ConfigLoader._load_uncertainty_history": {
    "file": "derek_beach.py",
    "questions": [
      "Q029"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Load historical uncertainty measurements",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "ConfigLoader._save_prior_history": {
    "file": "derek_beach.py",
    "questions": [
      "Q029"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "feedback_data",
          "anotacion": "dict[str, Any] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "uncertainty_reduction",
          "anotacion": "float | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(feedback_data: dict[str, Any] | None=None, uncertainty_reduction: float | None=None)",
      "descripcion": "Save prior history for learning across documents",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(feedback_data: dict[str, Any] | None=None, uncertainty_reduction: float | None=None)"
    }
  },
  "ConfigLoader.check_uncertainty_reduction_criterion": {
    "file": "derek_beach.py",
    "questions": [
      "Q029"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "current_uncertainty: float",
      "formato_salida": "dict con meets_criterion: bool, trend: str, reduction_rate: float",
      "calculo": "compara uncertainty actual vs histórico, calcula tasa de reducción",
      "parametros": "current_uncertainty: float",
      "parametros_configurables": [
        {
          "nombre": "current_uncertainty",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(current_uncertainty: float)",
      "descripcion": "Check if mean mechanism_type uncertainty has decreased ≥5% over 10 iterations"
    }
  },
  "ConfigLoader.update_priors_from_feedback": {
    "file": "derek_beach.py",
    "questions": [
      "Q029"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (actualización bayesiana)",
      "formato_entrada": "feedback_data: dict con {mechanism_type: accuracy_observed}",
      "formato_salida": "priors actualizados en config",
      "calculo": "weighted average: new_prior = (1-weight)*old_prior + weight*observed_accuracy",
      "parametros": "feedback_data: dict[str, Any]",
      "parametros_configurables": [
        {
          "nombre": "feedback_data",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(feedback_data: dict[str, Any])",
      "descripcion": "Self-reflective loop: Update priors based on audit feedback"
    }
  },
  "FinancialAuditor._calculate_sufficiency": {
    "file": "derek_beach.py",
    "questions": [
      "Q003",
      "Q012",
      "Q022"
    ],
    "dimensions": [
      "DIM01",
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "allocation: float, goal: MetaNode",
      "formato_salida": "float [0-1] suficiencia presupuestal",
      "calculo": "allocation / (unit_cost × target_quantity), clip [0,1]",
      "parametros": "allocation: float, goal: MetaNode",
      "parametros_configurables": [
        {
          "nombre": "allocation",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(allocation: float, target: float)",
      "descripcion": "Calculate if financial allocation is sufficient for target."
    }
  },
  "FinancialAuditor._detect_allocation_gaps": {
    "file": "derek_beach.py",
    "questions": [
      "Q002",
      "Q019"
    ],
    "dimensions": [
      "DIM01",
      "DIM04"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO + CUANTITATIVO",
      "formato_entrada": "allocations: dict, goals: list[MetaNode]",
      "formato_salida": "lista de gaps (goal_id, expected_amount, actual_amount, gap_ratio)",
      "calculo": "compara asignación real vs esperada, identifica metas sin presupuesto",
      "parametros": "allocations: dict, goals: list",
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode])",
      "descripcion": "Detect gaps in financial allocations."
    }
  },
  "FinancialAuditor._match_goal_to_budget": {
    "file": "derek_beach.py",
    "questions": [
      "Q003",
      "Q013"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "goal_id: str, budget_table: DataFrame",
      "formato_salida": "monto asignado, match_confidence",
      "calculo": "fuzzy matching entre goal_id y filas de tabla presupuestal, extrae monto",
      "parametros": "goal_id: str, budget_table: DataFrame",
      "parametros_configurables": [
        {
          "nombre": "goal_text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "budget_entries",
          "anotacion": "list[dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(goal_text: str, budget_entries: list[dict[str, Any]])",
      "descripcion": "Match a goal to budget entries."
    }
  },
  "FinancialAuditor._match_program_to_node": {
    "file": "derek_beach.py",
    "questions": [
      "Q003",
      "Q013"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "program_id",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(program_id: str, nodes: dict[str, MetaNode])",
      "descripcion": "Match program ID to existing node using fuzzy matching",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(program_id: str, nodes: dict[str, MetaNode])"
    }
  },
  "FinancialAuditor._parse_amount": {
    "file": "derek_beach.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "value",
          "anotacion": "Any",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(value: Any)",
      "descripcion": "Parse monetary amount from various formats",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(value: Any)"
    }
  },
  "FinancialAuditor._perform_counterfactual_budget_check": {
    "file": "derek_beach.py",
    "questions": [
      "Q003"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode], graph: nx.DiGraph)",
      "descripcion": "Harmonic Front 3 - Enhancement 5: Counterfactual Sufficiency Test for D3-Q3",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, MetaNode], graph: nx.DiGraph)"
    }
  },
  "FinancialAuditor._process_financial_table": {
    "file": "derek_beach.py",
    "questions": [
      "Q003",
      "Q006"
    ],
    "dimensions": [
      "DIM01",
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "table",
          "anotacion": "pd.DataFrame",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(table: pd.DataFrame, nodes: dict[str, MetaNode])",
      "descripcion": "Process a single financial table",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(table: pd.DataFrame, nodes: dict[str, MetaNode])"
    }
  },
  "FinancialAuditor.trace_financial_allocation": {
    "file": "derek_beach.py",
    "questions": [
      "Q003"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (montos)",
      "formato_entrada": "text: str, tables: list[pd.DataFrame]",
      "formato_salida": "trazabilidad de asignaciones: program→amount, gaps detectados, total budget",
      "calculo": "extrae montos de tablas, matchea con metas, calcula cobertura financiera",
      "parametros": "text: str, tables: list[DataFrame]",
      "parametros_configurables": [
        {
          "nombre": "tables",
          "anotacion": "list[pd.DataFrame]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(tables: list[pd.DataFrame], nodes: dict[str, MetaNode], graph: nx.DiGraph | None=None)",
      "descripcion": "Trace financial allocations to programs/goals"
    }
  },
  "HierarchicalGenerativeModel._ablation_analysis": {
    "file": "derek_beach.py",
    "questions": [
      "Q025"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "posterior_samples",
          "anotacion": "list[dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observed_data",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(posterior_samples: list[dict[str, Any]], observed_data: dict[str, Any])",
      "descripcion": "Mide caída en coherence al quitar pasos de secuencia",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(posterior_samples: list[dict[str, Any]], observed_data: dict[str, Any])"
    }
  },
  "HierarchicalGenerativeModel._calculate_ess": {
    "file": "derek_beach.py",
    "questions": [
      "Q014",
      "Q018",
      "Q028"
    ],
    "dimensions": [
      "DIM03",
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "samples",
          "anotacion": "list[dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(samples: list[dict[str, Any]])",
      "descripcion": "Calcula Effective Sample Size (simplificado)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(samples: list[dict[str, Any]])"
    }
  },
  "HierarchicalGenerativeModel._calculate_likelihood": {
    "file": "derek_beach.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "mechanism_type",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observations",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(mechanism_type: str, observations: dict[str, Any])",
      "descripcion": "Calcula likelihood de observations dado mechanism_type",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(mechanism_type: str, observations: dict[str, Any])"
    }
  },
  "HierarchicalGenerativeModel._calculate_r_hat": {
    "file": "derek_beach.py",
    "questions": [
      "Q014",
      "Q018",
      "Q028"
    ],
    "dimensions": [
      "DIM03",
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "chains",
          "anotacion": "list[list[dict[str, Any]]]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(chains: list[list[dict[str, Any]]])",
      "descripcion": "Calcula Gelman-Rubin R-hat para diagnóstico de convergencia",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(chains: list[list[dict[str, Any]]])"
    }
  },
  "HierarchicalGenerativeModel._calculate_waic_difference": {
    "file": "derek_beach.py",
    "questions": [
      "Q025"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: nx.DiGraph)",
      "descripcion": "Calcula ΔWAIC = WAIC_hierarchical - WAIC_null (simplificado)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: nx.DiGraph)"
    }
  },
  "HierarchicalGenerativeModel._generate_independence_tests": {
    "file": "derek_beach.py",
    "questions": [
      "Q017"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "n_tests",
          "anotacion": "int",
          "default": "3",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: nx.DiGraph, n_tests: int=3)",
      "descripcion": "Genera tests de independencia automáticamente desde DAG",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: nx.DiGraph, n_tests: int=3)"
    }
  },
  "HierarchicalGenerativeModel.posterior_predictive_check": {
    "file": "derek_beach.py",
    "questions": [
      "Q025"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "posterior_samples",
          "anotacion": "list[dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "observed_data",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(posterior_samples: list[dict[str, Any]], observed_data: dict[str, Any])",
      "descripcion": "PROMPT II-2: Posterior Predictive Checks + Ablation",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(posterior_samples: list[dict[str, Any]], observed_data: dict[str, Any])"
    }
  },
  "HierarchicalGenerativeModel.verify_conditional_independence": {
    "file": "derek_beach.py",
    "questions": [
      "Q017"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "independence_tests",
          "anotacion": "list[tuple[str, str, list[str]]] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: nx.DiGraph, independence_tests: list[tuple[str, str, list[str]]] | None=None)",
      "descripcion": "PROMPT II-3: Independencias y parsimonia",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: nx.DiGraph, independence_tests: list[tuple[str, str, list[str]]] | None=None)"
    }
  },
  "IndustrialGradeValidator._benchmark_operation": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q028"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "operation_name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "callable_obj",
          "anotacion": null,
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "threshold",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "args",
          "anotacion": null,
          "default": null,
          "kind": "var_positional"
        },
        {
          "nombre": "kwargs",
          "anotacion": null,
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(operation_name: str, callable_obj, threshold: float, *args, **kwargs)",
      "descripcion": "Mide el tiempo de ejecución de una operación y registra la métrica.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(operation_name: str, callable_obj, threshold: float, *args, **kwargs)"
    }
  },
  "IndustrialGradeValidator._log_metric": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "value",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "unit",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "threshold",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(name: str, value: float, unit: str, threshold: float)",
      "descripcion": "Registra y reporta una métrica de validación.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(name: str, value: float, unit: str, threshold: float)"
    }
  },
  "IndustrialGradeValidator.execute_suite": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q028"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Ejecuta la suite completa de validación industrial.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialGradeValidator.run_performance_benchmarks": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Ejecuta benchmarks de rendimiento para las operaciones críticas del motor.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialGradeValidator.validate_causal_categories": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Valida la completitud y el orden axiomático de las categorías causales.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialGradeValidator.validate_connection_matrix": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q027"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Valida la matriz de transiciones causales.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialGradeValidator.validate_engine_readiness": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014",
      "Q028"
    ],
    "dimensions": [
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Valida la disponibilidad y tiempo de instanciación de los motores de análisis.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialPolicyProcessor._analyze_causal_dimensions": {
    "file": "policy_processor.py",
    "questions": [
      "Q005",
      "Q007",
      "Q020"
    ],
    "dimensions": [
      "DIM01",
      "DIM02",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "sentences",
          "anotacion": "list[str] | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, sentences: list[str] | None=None)",
      "descripcion": "Perform global analysis of causal dimensions across entire document.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, sentences: list[str] | None=None)"
    }
  },
  "IndustrialPolicyProcessor._build_point_patterns": {
    "file": "policy_processor.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "LEGACY: Pattern building from questionnaire disabled.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialPolicyProcessor._calculate_quality_score": {
    "file": "policy_processor.py",
    "questions": [
      "Q011",
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dimension_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "contradiction_bundle",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "performance_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dimension_analysis: dict[str, Any], contradiction_bundle: dict[str, Any], performance_analysis: dict[str, Any])",
      "descripcion": "Aggregate key indicators into a structured QualityScore dataclass.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dimension_analysis: dict[str, Any], contradiction_bundle: dict[str, Any], performance_analysis: dict[str, Any])"
    }
  },
  "IndustrialPolicyProcessor._compile_pattern_registry": {
    "file": "policy_processor.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Compile all causal patterns into efficient regex objects.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialPolicyProcessor._compute_avg_confidence": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dimension_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dimension_analysis: dict[str, Any])",
      "descripcion": "Calculate average confidence across all dimensions.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dimension_analysis: dict[str, Any])"
    }
  },
  "IndustrialPolicyProcessor._compute_evidence_confidence": {
    "file": "policy_processor.py",
    "questions": [
      "Q013",
      "Q022"
    ],
    "dimensions": [
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "matches",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text_length",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "pattern_specificity",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": "Any",
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(matches: list[str], text_length: int, pattern_specificity: float, **kwargs)",
      "descripcion": "Calculate confidence score for evidence based on pattern matches and contextual factors.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(matches: list[str], text_length: int, pattern_specificity: float, **kwargs)"
    }
  },
  "IndustrialPolicyProcessor._construct_evidence_bundle": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dimension",
          "anotacion": "CausalDimension",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "category",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "matches",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "positions",
          "anotacion": "list[int]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "confidence",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": "Any",
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(dimension: CausalDimension, category: str, matches: list[str], positions: list[int], confidence: float, **kwargs)",
      "descripcion": "Assemble evidence bundle from matched patterns and computed confidence.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dimension: CausalDimension, category: str, matches: list[str], positions: list[int], confidence: float, **kwargs)"
    }
  },
  "IndustrialPolicyProcessor._empty_result": {
    "file": "policy_processor.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Return structure for failed/empty processing.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialPolicyProcessor._extract_metadata": {
    "file": "policy_processor.py",
    "questions": [
      "Q005",
      "Q011"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Extract key metadata from policy document header.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "IndustrialPolicyProcessor._extract_point_evidence": {
    "file": "policy_processor.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "sentences",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "point_code",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, sentences: list[str], point_code: str)",
      "descripcion": "Extract evidence for a specific policy point across all dimensions.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, sentences: list[str], point_code: str)"
    }
  },
  "IndustrialPolicyProcessor._load_questionnaire": {
    "file": "policy_processor.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "LEGACY: Questionnaire loading disabled.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "IndustrialPolicyProcessor._match_patterns_in_sentences": {
    "file": "policy_processor.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "compiled_patterns",
          "anotacion": "list",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "relevant_sentences",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": "Any",
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(compiled_patterns: list, relevant_sentences: list[str], **kwargs)",
      "descripcion": "Execute pattern matching across relevant sentences and collect matches with positions.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(compiled_patterns: list, relevant_sentences: list[str], **kwargs)"
    }
  },
  "IndustrialPolicyProcessor.export_results": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "results",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "output_path",
          "anotacion": "str | Path",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(results: dict[str, Any], output_path: str | Path)",
      "descripcion": "Export analysis results to JSON with formatted output.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(results: dict[str, Any], output_path: str | Path)"
    }
  },
  "IndustrialPolicyProcessor.process": {
    "file": "policy_processor.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "raw_text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": "Any",
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(raw_text: str, **kwargs)",
      "descripcion": "Execute comprehensive policy plan analysis.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(raw_text: str, **kwargs)"
    }
  },
  "MechanismPartExtractor._calculate_ea_confidence": {
    "file": "derek_beach.py",
    "questions": [
      "Q004"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entity",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "activity",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "context",
          "anotacion": "str",
          "default": "''",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entity: str, activity: str, context: str='')",
      "descripcion": "Calculate confidence for an entity-activity pair.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entity: str, activity: str, context: str='')"
    }
  },
  "MechanismPartExtractor._normalize_entity": {
    "file": "derek_beach.py",
    "questions": [
      "Q004"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entity",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entity: str)",
      "descripcion": "Normalize entity name using aliases",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entity: str)"
    }
  },
  "MechanismPartExtractor._validate_entity_activity": {
    "file": "derek_beach.py",
    "questions": [
      "Q004"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entity",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "activity",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entity: str, activity: str)",
      "descripcion": "Validate that an entity-activity pair makes sense.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entity: str, activity: str)"
    }
  },
  "MechanismPartExtractor.extract_entity_activity": {
    "file": "derek_beach.py",
    "questions": [
      "Q004"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Extract Entity-Activity tuple from text",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "OperationalizationAuditor._audit_direct_evidence": {
    "file": "derek_beach.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "scm_dag",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "historical_data",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode], scm_dag: nx.DiGraph, historical_data: dict[str, Any])",
      "descripcion": "Layer 1: Audit direct evidence of required components",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, MetaNode], scm_dag: nx.DiGraph, historical_data: dict[str, Any])"
    }
  },
  "OperationalizationAuditor._audit_systemic_risk": {
    "file": "derek_beach.py",
    "questions": [
      "Q002",
      "Q009",
      "Q024"
    ],
    "dimensions": [
      "DIM01",
      "DIM02",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "direct_evidence",
          "anotacion": "dict[str, dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_implications",
          "anotacion": "dict[str, dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "pdet_alignment",
          "anotacion": "float | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode], graph: nx.DiGraph, direct_evidence: dict[str, dict[str, Any]], causal_implications: dict[str, dict[str, Any]], pdet_alignment: float | None=None)",
      "descripcion": "AUDIT POINT 2.3: Policy Alignment Dual Constraint",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, MetaNode], graph: nx.DiGraph, direct_evidence: dict[str, dict[str, Any]], causal_implications: dict[str, dict[str, Any]], pdet_alignment: float | None=None)"
    }
  },
  "OperationalizationAuditor._generate_optimal_remediations": {
    "file": "derek_beach.py",
    "questions": [
      "Q019"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "direct_evidence",
          "anotacion": "dict[str, dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_implications",
          "anotacion": "dict[str, dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "systemic_risk",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(direct_evidence: dict[str, dict[str, Any]], causal_implications: dict[str, dict[str, Any]], systemic_risk: dict[str, Any])",
      "descripcion": "Generate prioritized remediation recommendations",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(direct_evidence: dict[str, dict[str, Any]], causal_implications: dict[str, dict[str, Any]], systemic_risk: dict[str, Any])"
    }
  },
  "OperationalizationAuditor._get_remediation_text": {
    "file": "derek_beach.py",
    "questions": [
      "Q019"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "omission",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "node_id",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(omission: str, node_id: str)",
      "descripcion": "Get specific remediation text for an omission",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(omission: str, node_id: str)"
    }
  },
  "OperationalizationAuditor.audit_evidence_traceability": {
    "file": "derek_beach.py",
    "questions": [
      "Q004",
      "Q011"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(nodes: dict[str, MetaNode])",
      "descripcion": "Audit evidence traceability for all nodes",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(nodes: dict[str, MetaNode])"
    }
  },
  "OperationalizationAuditor.audit_sequence_logic": {
    "file": "derek_beach.py",
    "questions": [
      "Q010"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(graph: nx.DiGraph)",
      "descripcion": "Audit logical sequence of activities",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(graph: nx.DiGraph)"
    }
  },
  "PDETMunicipalPlanAnalyzer._analyze_funding_sources": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q003"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "indicators",
          "anotacion": "list[FinancialIndicator]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(indicators: list[FinancialIndicator], tables: list[ExtractedTable])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(indicators: list[FinancialIndicator], tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer._assess_financial_sustainability": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "indicators",
          "anotacion": "list[FinancialIndicator]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "funding_sources",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(indicators: list[FinancialIndicator], funding_sources: dict[str, Any])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(indicators: list[FinancialIndicator], funding_sources: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer._bayesian_risk_inference": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q009"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "indicators",
          "anotacion": "list[FinancialIndicator]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "funding_sources",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "sustainability",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(indicators: list[FinancialIndicator], funding_sources: dict[str, Any], sustainability: float)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(indicators: list[FinancialIndicator], funding_sources: dict[str, Any], sustainability: float)"
    }
  },
  "PDETMunicipalPlanAnalyzer._break_cycles": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q024"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "G",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(G: nx.DiGraph)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(G: nx.DiGraph)"
    }
  },
  "PDETMunicipalPlanAnalyzer._classify_entity_type": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q004"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(name: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(name: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._classify_tables": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q003",
      "Q006"
    ],
    "dimensions": [
      "DIM01",
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(tables: list[ExtractedTable])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer._clean_dataframe": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q006"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "df",
          "anotacion": "pd.DataFrame",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(df: pd.DataFrame)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(df: pd.DataFrame)"
    }
  },
  "PDETMunicipalPlanAnalyzer._compute_e_value": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q009",
      "Q022",
      "Q025"
    ],
    "dimensions": [
      "DIM02",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "effect",
          "anotacion": "CausalEffect",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(effect: CausalEffect)",
      "descripcion": "E-value: mínima fuerza de confounding no observado para anular el efecto",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(effect: CausalEffect)"
    }
  },
  "PDETMunicipalPlanAnalyzer._compute_robustness_value": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q009",
      "Q018",
      "Q022",
      "Q025"
    ],
    "dimensions": [
      "DIM02",
      "DIM04",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "effect",
          "anotacion": "CausalEffect",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(effect: CausalEffect, dag: CausalDAG)",
      "descripcion": "Robustness Value: percentil de la distribución posterior que cruza cero",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(effect: CausalEffect, dag: CausalDAG)"
    }
  },
  "PDETMunicipalPlanAnalyzer._consolidate_entities": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q004",
      "Q013"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entities",
          "anotacion": "list[ResponsibleEntity]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entities: list[ResponsibleEntity])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entities: list[ResponsibleEntity])"
    }
  },
  "PDETMunicipalPlanAnalyzer._deduplicate_tables": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q006",
      "Q012"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(tables: list[ExtractedTable])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer._effect_to_dict": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "effect",
          "anotacion": "CausalEffect",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(effect: CausalEffect)",
      "descripcion": "Convierte CausalEffect a diccionario",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(effect: CausalEffect)"
    }
  },
  "PDETMunicipalPlanAnalyzer._entity_to_dict": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entity",
          "anotacion": "ResponsibleEntity",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entity: ResponsibleEntity)",
      "descripcion": "Convierte ResponsibleEntity a diccionario",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entity: ResponsibleEntity)"
    }
  },
  "PDETMunicipalPlanAnalyzer._estimate_effect_bayesian": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q018"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "treatment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "outcome",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(treatment: str, outcome: str, dag: CausalDAG, financial_analysis: dict[str, Any])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(treatment: str, outcome: str, dag: CausalDAG, financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer._estimate_score_confidence": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "scores",
          "anotacion": "np.ndarray",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "weights",
          "anotacion": "np.ndarray",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(scores: np.ndarray, weights: np.ndarray)",
      "descripcion": "Estima intervalo de confianza para el score usando bootstrap",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(scores: np.ndarray, weights: np.ndarray)"
    }
  },
  "PDETMunicipalPlanAnalyzer._extract_budget_for_pillar": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q003"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "pillar",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(pillar: str, text: str, financial_analysis: dict[str, Any])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(pillar: str, text: str, financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer._extract_entities_ner": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q004",
      "Q016"
    ],
    "dimensions": [
      "DIM01",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._extract_entities_syntax": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q004",
      "Q016"
    ],
    "dimensions": [
      "DIM01",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._extract_financial_amounts": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer._extract_from_budget_table": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "df",
          "anotacion": "pd.DataFrame",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(df: pd.DataFrame)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(df: pd.DataFrame)"
    }
  },
  "PDETMunicipalPlanAnalyzer._extract_from_responsibility_tables": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(tables: list[ExtractedTable])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer._find_mediator_mentions": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q021",
      "Q023"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "mediator",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, mediator: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, mediator: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._find_outcome_mentions": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "outcome",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, outcome: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, outcome: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._generate_optimal_remediations": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "gaps",
          "anotacion": "list[dict[str, Any]]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(gaps: list[dict[str, Any]])",
      "descripcion": "Generate optimal remediations for identified gaps.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(gaps: list[dict[str, Any]])"
    }
  },
  "PDETMunicipalPlanAnalyzer._generate_recommendations": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q012",
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "analysis_results",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(analysis_results: dict[str, Any])",
      "descripcion": "Genera recomendaciones específicas basadas en el análisis",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(analysis_results: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer._generate_scenario_narrative": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q021"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "description",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "intervention",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "predicted_outcomes",
          "anotacion": "dict[str, tuple[float, float, float]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "probabilities",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(description: str, intervention: dict[str, float], predicted_outcomes: dict[str, tuple[float, float, float]], probabilities: dict[str, float])",
      "descripcion": "Genera narrativa interpretable del escenario contrafactual",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(description: str, intervention: dict[str, float], predicted_outcomes: dict[str, tuple[float, float, float]], probabilities: dict[str, float])"
    }
  },
  "PDETMunicipalPlanAnalyzer._get_prior_effect": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q018"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "treatment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "outcome",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(treatment: str, outcome: str)",
      "descripcion": "Priors informados basados en meta-análisis de programas PDET",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(treatment: str, outcome: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._get_spanish_stopwords": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "PDETMunicipalPlanAnalyzer._identify_causal_edges": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q008"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "nodes",
          "anotacion": "dict[str, CausalNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, nodes: dict[str, CausalNode])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, nodes: dict[str, CausalNode])"
    }
  },
  "PDETMunicipalPlanAnalyzer._identify_causal_nodes": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable], financial_analysis: dict[str, Any])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, tables: list[ExtractedTable], financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer._identify_confounders": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "treatment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "outcome",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(treatment: str, outcome: str, dag: CausalDAG)",
      "descripcion": "Identifica confounders usando d-separation (Pearl, 2009)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(treatment: str, outcome: str, dag: CausalDAG)"
    }
  },
  "PDETMunicipalPlanAnalyzer._identify_funding_source": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q003"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "context",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(context: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(context: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._indicator_to_dict": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "ind",
          "anotacion": "FinancialIndicator",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(ind: FinancialIndicator)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(ind: FinancialIndicator)"
    }
  },
  "PDETMunicipalPlanAnalyzer._interpret_overall_quality": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "score",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(score: float)",
      "descripcion": "Interpretación del score global",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(score: float)"
    }
  },
  "PDETMunicipalPlanAnalyzer._interpret_risk": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q009",
      "Q012",
      "Q024"
    ],
    "dimensions": [
      "DIM02",
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "risk",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(risk: float)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(risk: float)"
    }
  },
  "PDETMunicipalPlanAnalyzer._interpret_sensitivity": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q009",
      "Q022",
      "Q024"
    ],
    "dimensions": [
      "DIM02",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "e_value",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "robustness",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(e_value: float, robustness: float)",
      "descripcion": "Interpretación de resultados de sensibilidad",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(e_value: float, robustness: float)"
    }
  },
  "PDETMunicipalPlanAnalyzer._is_likely_header": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q006"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "row",
          "anotacion": "pd.Series",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": null,
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(row: pd.Series, **kwargs)",
      "descripcion": "Determine if a DataFrame row is likely a header row based on linguistic analysis.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(row: pd.Series, **kwargs)"
    }
  },
  "PDETMunicipalPlanAnalyzer._quality_to_dict": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "quality",
          "anotacion": "QualityScore",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(quality: QualityScore)",
      "descripcion": "Convierte QualityScore a diccionario",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(quality: QualityScore)"
    }
  },
  "PDETMunicipalPlanAnalyzer._refine_edge_probabilities": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q008",
      "Q015"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "edges",
          "anotacion": "list[CausalEdge]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "nodes",
          "anotacion": "dict[str, CausalNode]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(edges: list[CausalEdge], text: str, nodes: dict[str, CausalNode])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(edges: list[CausalEdge], text: str, nodes: dict[str, CausalNode])"
    }
  },
  "PDETMunicipalPlanAnalyzer._scenario_to_dict": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "scenario",
          "anotacion": "CounterfactualScenario",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(scenario: CounterfactualScenario)",
      "descripcion": "Convierte CounterfactualScenario a diccionario",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(scenario: CounterfactualScenario)"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_causal_coherence": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q010",
      "Q020"
    ],
    "dimensions": [
      "DIM02",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "effects",
          "anotacion": "list[CausalEffect]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: CausalDAG, effects: list[CausalEffect])",
      "descripcion": "Score coherencia causal del plan (0-10)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: CausalDAG, effects: list[CausalEffect])"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_entity_specificity": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q004"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entities",
          "anotacion": "list[ResponsibleEntity]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "full_text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entities: list[ResponsibleEntity], full_text: str)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entities: list[ResponsibleEntity], full_text: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_financial_component": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q003"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(financial_analysis: dict[str, Any])",
      "descripcion": "Score componente financiero (0-10)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_indicators": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q011",
      "Q012",
      "Q016"
    ],
    "dimensions": [
      "DIM03",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(tables: list[ExtractedTable], text: str)",
      "descripcion": "Score calidad de indicadores (0-10)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(tables: list[ExtractedTable], text: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_pdet_alignment": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q020"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable], dag: CausalDAG)",
      "descripcion": "Score alineación con pilares PDET (0-10)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, tables: list[ExtractedTable], dag: CausalDAG)"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_responsibility_clarity": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "entities",
          "anotacion": "list[ResponsibleEntity]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(entities: list[ResponsibleEntity])",
      "descripcion": "Score claridad de responsables (0-10)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(entities: list[ResponsibleEntity])"
    }
  },
  "PDETMunicipalPlanAnalyzer._score_temporal_consistency": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable])",
      "descripcion": "Score consistencia temporal (0-10)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer._simulate_intervention": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q002",
      "Q015",
      "Q021"
    ],
    "dimensions": [
      "DIM01",
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "intervention",
          "anotacion": "dict[str, float]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_effects",
          "anotacion": "list[CausalEffect]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "description",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(intervention: dict[str, float], dag: CausalDAG, causal_effects: list[CausalEffect], description: str)",
      "descripcion": "Simula intervención usando do-calculus (Pearl, 2009)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(intervention: dict[str, float], dag: CausalDAG, causal_effects: list[CausalEffect], description: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer.analyze_financial_feasibility": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q003",
      "Q012",
      "Q015"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "tables: list[DataFrame], text: str",
      "formato_salida": "feasibility_score [0-1], funding_gaps, sustainability_assessment",
      "calculo": "extrae presupuestos, calcula ratio ingresos/gastos, proyección temporal",
      "parametros": "tables: list[DataFrame], text: str",
      "parametros_configurables": [
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(tables: list[ExtractedTable], text: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer.calculate_quality_score": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "responsible_entities",
          "anotacion": "list[ResponsibleEntity]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_effects",
          "anotacion": "list[CausalEffect]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable], financial_analysis: dict[str, Any], responsible_entities: list[ResponsibleEntity], causal_dag: CausalDAG, causal_effects: list[CausalEffect])",
      "descripcion": "Puntaje bayesiano integral de calidad del PDM",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, tables: list[ExtractedTable], financial_analysis: dict[str, Any], responsible_entities: list[ResponsibleEntity], causal_dag: CausalDAG, causal_effects: list[CausalEffect])"
    }
  },
  "PDETMunicipalPlanAnalyzer.construct_causal_dag": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q007",
      "Q015"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable], financial_analysis: dict[str, Any])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, tables: list[ExtractedTable], financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer.estimate_causal_effects": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: CausalDAG, text: str, financial_analysis: dict[str, Any])",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: CausalDAG, text: str, financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer.export_causal_network": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q026"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "output_path",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: CausalDAG, output_path: str)",
      "descripcion": "Exporta el DAG causal en formato GraphML para Gephi/Cytoscape",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: CausalDAG, output_path: str)"
    }
  },
  "PDETMunicipalPlanAnalyzer.generate_counterfactuals": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q015",
      "Q021"
    ],
    "dimensions": [
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "causal_effects",
          "anotacion": "list[CausalEffect]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(dag: CausalDAG, causal_effects: list[CausalEffect], financial_analysis: dict[str, Any])",
      "descripcion": "Genera escenarios contrafactuales usando el framework de Pearl (2009)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(dag: CausalDAG, causal_effects: list[CausalEffect], financial_analysis: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer.generate_executive_report": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "analysis_results",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(analysis_results: dict[str, Any])",
      "descripcion": "Genera reporte ejecutivo en Markdown",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(analysis_results: dict[str, Any])"
    }
  },
  "PDETMunicipalPlanAnalyzer.identify_responsible_entities": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q004",
      "Q013"
    ],
    "dimensions": [
      "DIM01",
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "PATRON (NER)",
      "formato_entrada": "text: str, tables: list[DataFrame]",
      "formato_salida": "lista de entidades responsables con type (secretaría, ONG, comunidad), confidence",
      "calculo": "NER spaCy + extracción de tablas de responsabilidades, consolidación",
      "parametros": "text: str, tables: list",
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "tables",
          "anotacion": "list[ExtractedTable]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, tables: list[ExtractedTable])"
    }
  },
  "PDETMunicipalPlanAnalyzer.sensitivity_analysis": {
    "file": "financiero_viabilidad_tablas copy.py",
    "questions": [
      "Q009"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "model: dict, perturbation_range: float",
      "formato_salida": "sensitivity_map por variable, critical_variables, robustness_score",
      "calculo": "perturba cada variable ±range%, mide impacto en output, identifica alta sensibilidad",
      "parametros": "model: dict, perturbation_range: float=0.10",
      "parametros_configurables": [
        {
          "nombre": "causal_effects",
          "anotacion": "list[CausalEffect]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "dag",
          "anotacion": "CausalDAG",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(causal_effects: list[CausalEffect], dag: CausalDAG)",
      "descripcion": "Análisis de sensibilidad para supuestos de identificación causal"
    }
  },
  "PDFProcessor.extract_tables": {
    "file": "derek_beach.py",
    "questions": [
      "Q006"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Extract tables from PDF",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "PerformanceAnalyzer._calculate_loss_functions": {
    "file": "analyzer_one.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "metrics: dict, link_config: ValueChainLink",
      "formato_salida": "dict con funciones de pérdida operacional",
      "calculo": "loss = 1 - efficiency_score × capacity_utilization, penalizaciones por bottlenecks",
      "parametros": "metrics: dict, link_config: ValueChainLink",
      "parametros_configurables": [
        {
          "nombre": "metrics",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "link_config",
          "anotacion": "ValueChainLink",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(metrics: dict[str, Any], link_config: ValueChainLink)",
      "descripcion": "Calculate operational loss functions."
    }
  },
  "PerformanceAnalyzer._generate_recommendations": {
    "file": "analyzer_one.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO (texto)",
      "formato_entrada": "performance_analysis: dict completo",
      "formato_salida": "list[str] de recomendaciones priorizadas",
      "calculo": "genera recomendaciones basadas en bottlenecks detectados y loss functions > threshold",
      "parametros": "performance_analysis: dict",
      "parametros_configurables": [
        {
          "nombre": "performance_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(performance_analysis: dict[str, Any])",
      "descripcion": "Generate optimization recommendations."
    }
  },
  "PerformanceAnalyzer.analyze_performance": {
    "file": "analyzer_one.py",
    "questions": [
      "Q002",
      "Q014",
      "Q016",
      "Q028"
    ],
    "dimensions": [
      "DIM01",
      "DIM03",
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (métricas agregadas)",
      "formato_entrada": "semantic_cube: dict (output de SemanticAnalyzer)",
      "formato_salida": "value_chain_metrics, bottleneck_analysis, operational_loss_functions, recommendations",
      "calculo": "throughput = segments × coherence × conversion_rate, bottlenecks por IsolationForest, loss functions",
      "parametros": "semantic_cube: dict[str, Any]",
      "parametros_configurables": [
        {
          "nombre": "semantic_cube",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(semantic_cube: dict[str, Any])",
      "descripcion": "Analyze performance indicators across value chain links."
    }
  },
  "PolicyAnalysisEmbedder._apply_mmr": {
    "file": "embedding_policy.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "ranked_results",
          "anotacion": "list[tuple[SemanticChunk, float]]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(ranked_results: list[tuple[SemanticChunk, float]])",
      "descripcion": "Apply Maximal Marginal Relevance for diversification.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(ranked_results: list[tuple[SemanticChunk, float]])"
    }
  },
  "PolicyAnalysisEmbedder._compute_overall_confidence": {
    "file": "embedding_policy.py",
    "questions": [
      "Q022",
      "Q027"
    ],
    "dimensions": [
      "DIM05",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "relevant_chunks",
          "anotacion": "list[tuple[SemanticChunk, float]]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "numerical_eval",
          "anotacion": "BayesianEvaluation",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(relevant_chunks: list[tuple[SemanticChunk, float]], numerical_eval: BayesianEvaluation)",
      "descripcion": "Compute overall confidence score combining semantic and numerical evidence.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(relevant_chunks: list[tuple[SemanticChunk, float]], numerical_eval: BayesianEvaluation)"
    }
  },
  "PolicyAnalysisEmbedder._embed_texts": {
    "file": "embedding_policy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "texts",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(texts: list[str])",
      "descripcion": "Generate embeddings with caching and retry logic.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(texts: list[str])"
    }
  },
  "PolicyAnalysisEmbedder._extract_numerical_values": {
    "file": "embedding_policy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(chunks: list[SemanticChunk])",
      "descripcion": "Extract numerical values from chunks using advanced patterns.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(chunks: list[SemanticChunk])"
    }
  },
  "PolicyAnalysisEmbedder._filter_by_pdq": {
    "file": "embedding_policy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "pdq_filter",
          "anotacion": "PDQIdentifier",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(chunks: list[SemanticChunk], pdq_filter: PDQIdentifier)",
      "descripcion": "Filter chunks by P-D-Q context.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(chunks: list[SemanticChunk], pdq_filter: PDQIdentifier)"
    }
  },
  "PolicyAnalysisEmbedder._generate_query_from_pdq": {
    "file": "embedding_policy.py",
    "questions": [
      "Q013",
      "Q022"
    ],
    "dimensions": [
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "pdq",
          "anotacion": "PDQIdentifier",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(pdq: PDQIdentifier)",
      "descripcion": "Generate search query from P-D-Q identifier.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(pdq: PDQIdentifier)"
    }
  },
  "PolicyAnalysisEmbedder.compare_policy_interventions": {
    "file": "embedding_policy.py",
    "questions": [
      "Q015"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "intervention_a_chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "intervention_b_chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "pdq_context",
          "anotacion": "PDQIdentifier",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(intervention_a_chunks: list[SemanticChunk], intervention_b_chunks: list[SemanticChunk], pdq_context: PDQIdentifier)",
      "descripcion": "Bayesian comparison of two policy interventions.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(intervention_a_chunks: list[SemanticChunk], intervention_b_chunks: list[SemanticChunk], pdq_context: PDQIdentifier)"
    }
  },
  "PolicyAnalysisEmbedder.evaluate_policy_numerical_consistency": {
    "file": "embedding_policy.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "pdq_context",
          "anotacion": "PDQIdentifier",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(chunks: list[SemanticChunk], pdq_context: PDQIdentifier)",
      "descripcion": "Bayesian evaluation of numerical consistency for policy metric.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(chunks: list[SemanticChunk], pdq_context: PDQIdentifier)"
    }
  },
  "PolicyAnalysisEmbedder.generate_pdq_report": {
    "file": "embedding_policy.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "document_chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "target_pdq",
          "anotacion": "PDQIdentifier",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(document_chunks: list[SemanticChunk], target_pdq: PDQIdentifier)",
      "descripcion": "Generate comprehensive analytical report for P-D-Q question.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(document_chunks: list[SemanticChunk], target_pdq: PDQIdentifier)"
    }
  },
  "PolicyAnalysisEmbedder.get_diagnostics": {
    "file": "embedding_policy.py",
    "questions": [
      "Q022",
      "Q023"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Get system diagnostics and performance metrics.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "PolicyAnalysisEmbedder.process_document": {
    "file": "embedding_policy.py",
    "questions": [
      "Q013",
      "Q022"
    ],
    "dimensions": [
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "VECTORIAL (embeddings)",
      "formato_entrada": "document: str",
      "formato_salida": "embedded_chunks: list[np.array], metadata: dict",
      "calculo": "segmenta documento, genera embeddings sentence-transformers, almacena metadata",
      "parametros": "document: str",
      "parametros_configurables": [
        {
          "nombre": "document_text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "document_metadata",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(document_text: str, document_metadata: dict[str, Any])",
      "descripcion": "Process complete PDM document into semantic chunks with embeddings."
    }
  },
  "PolicyAnalysisEmbedder.semantic_search": {
    "file": "embedding_policy.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "VECTORIAL + RANKING",
      "formato_entrada": "query: str, top_k: int",
      "formato_salida": "lista de chunks ordenados por similaridad coseno con scores",
      "calculo": "embed query → cosine similarity con todos los chunks → top_k",
      "parametros": "query: str, top_k: int=5",
      "parametros_configurables": [
        {
          "nombre": "query",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "document_chunks",
          "anotacion": "list[SemanticChunk]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "pdq_filter",
          "anotacion": "PDQIdentifier | None",
          "default": "None",
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "use_reranking",
          "anotacion": "bool",
          "default": "True",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(query: str, document_chunks: list[SemanticChunk], pdq_filter: PDQIdentifier | None=None, use_reranking: bool=True)",
      "descripcion": "Advanced semantic search with P-D-Q filtering and reranking."
    }
  },
  "PolicyContradictionDetector._calculate_coherence_metrics": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q010"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "document_sections: dict",
      "formato_salida": "coherence_score [0-1], fragmentation_index, alignment_score",
      "calculo": "mide conectividad semántica entre secciones, penaliza fragmentación",
      "parametros": "document_sections: dict",
      "parametros_configurables": [
        {
          "nombre": "contradictions",
          "anotacion": "list[ContradictionEvidence]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "statements",
          "anotacion": "list[PolicyStatement]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(contradictions: list[ContradictionEvidence], statements: list[PolicyStatement], text: str)",
      "descripcion": "Calcula métricas avanzadas de coherencia del documento"
    }
  },
  "PolicyContradictionDetector._calculate_graph_fragmentation": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q010"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Calcula fragmentación del grafo de conocimiento",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "PolicyContradictionDetector._calculate_numerical_divergence": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "claim_a",
          "anotacion": "dict",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "claim_b",
          "anotacion": "dict",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(claim_a: dict, claim_b: dict)",
      "descripcion": "Calcula divergencia entre valores numéricos",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(claim_a: dict, claim_b: dict)"
    }
  },
  "PolicyContradictionDetector._calculate_objective_alignment": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q010",
      "Q019"
    ],
    "dimensions": [
      "DIM02",
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "statements",
          "anotacion": "list[PolicyStatement]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(statements: list[PolicyStatement])",
      "descripcion": "Calcula alineación entre objetivos declarados",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(statements: list[PolicyStatement])"
    }
  },
  "PolicyContradictionDetector._detect_logical_incompatibilities": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q010"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "statements",
          "anotacion": "list[PolicyStatement]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(statements: list[PolicyStatement])",
      "descripcion": "Detecta incompatibilidades lógicas usando razonamiento en grafo",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(statements: list[PolicyStatement])"
    }
  },
  "PolicyContradictionDetector._detect_numerical_inconsistencies": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q002"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (divergencia)",
      "formato_entrada": "claims: list[dict] con valores numéricos",
      "formato_salida": "lista de inconsistencias con location_a, location_b, divergence_ratio",
      "calculo": "compara claims numéricas sobre mismo concepto, divergence > threshold → inconsistencia",
      "parametros": "claims: list[dict]",
      "parametros_configurables": [
        {
          "nombre": "statements",
          "anotacion": "list[PolicyStatement]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(statements: list[PolicyStatement])",
      "descripcion": "Detecta inconsistencias numéricas con análisis estadístico"
    }
  },
  "PolicyContradictionDetector._extract_quantitative_claims": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Extrae afirmaciones cuantitativas estructuradas",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "PolicyContradictionDetector._generate_resolution_recommendations": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q019"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "contradictions",
          "anotacion": "list[ContradictionEvidence]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(contradictions: list[ContradictionEvidence])",
      "descripcion": "Genera recomendaciones específicas para resolver contradicciones",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(contradictions: list[ContradictionEvidence])"
    }
  },
  "PolicyContradictionDetector._identify_affected_sections": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q019"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "conflicts",
          "anotacion": "list[ContradictionEvidence]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(conflicts: list[ContradictionEvidence])",
      "descripcion": "Identifica secciones del plan afectadas por contradicciones",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(conflicts: list[ContradictionEvidence])"
    }
  },
  "PolicyContradictionDetector._parse_number": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Parsea número desde texto",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "PolicyContradictionDetector._statistical_significance_test": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "claim_a",
          "anotacion": "dict",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "claim_b",
          "anotacion": "dict",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(claim_a: dict, claim_b: dict)",
      "descripcion": "Realiza test de significancia estadística",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(claim_a: dict, claim_b: dict)"
    }
  },
  "PolicyTextProcessor.compile_pattern": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "pattern_str",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(pattern_str: str)",
      "descripcion": "Cache and compile regex patterns for performance.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(pattern_str: str)"
    }
  },
  "PolicyTextProcessor.extract_contextual_window": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "match_position",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "window_size",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, match_position: int, window_size: int)",
      "descripcion": "Extract semantically coherent context window around a match.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, match_position: int, window_size: int)"
    }
  },
  "PolicyTextProcessor.normalize_unicode": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Apply canonical Unicode normalization (NFC/NFKC).",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "PolicyTextProcessor.segment_into_sentences": {
    "file": "policy_processor.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "kwargs",
          "anotacion": "Any",
          "default": null,
          "kind": "var_keyword"
        }
      ],
      "firma": "(text: str, **kwargs)",
      "descripcion": "Segment text into sentences with context-aware boundary detection.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str, **kwargs)"
    }
  },
  "ReportingEngine._calculate_quality_score": {
    "file": "derek_beach.py",
    "questions": [
      "Q022"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "traceability",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "financial",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "logic",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "ea",
          "anotacion": "float",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(traceability: float, financial: float, logic: float, ea: float)",
      "descripcion": "Calculate overall quality score (0-100)",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(traceability: float, financial: float, logic: float, ea: float)"
    }
  },
  "ReportingEngine.generate_accountability_matrix": {
    "file": "derek_beach.py",
    "questions": [
      "Q006",
      "Q013"
    ],
    "dimensions": [
      "DIM02",
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_code",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(graph: nx.DiGraph, policy_code: str)",
      "descripcion": "Generate accountability matrix in Markdown",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(graph: nx.DiGraph, policy_code: str)"
    }
  },
  "ReportingEngine.generate_causal_diagram": {
    "file": "derek_beach.py",
    "questions": [
      "Q026"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_code",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(graph: nx.DiGraph, policy_code: str)",
      "descripcion": "Generate causal diagram visualization",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(graph: nx.DiGraph, policy_code: str)"
    }
  },
  "ReportingEngine.generate_causal_model_json": {
    "file": "derek_beach.py",
    "questions": [
      "Q026"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "graph",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "nodes",
          "anotacion": "dict[str, MetaNode]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_code",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(graph: nx.DiGraph, nodes: dict[str, MetaNode], policy_code: str)",
      "descripcion": "Generate structured JSON export of causal model",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(graph: nx.DiGraph, nodes: dict[str, MetaNode], policy_code: str)"
    }
  },
  "SemanticAnalyzer._calculate_semantic_complexity": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO",
      "formato_entrada": "semantic_cube: dict",
      "formato_salida": "float [0-1] complejidad semántica",
      "calculo": "cuenta conceptos únicos en todas las dimensiones, normaliza por max_expected (20)",
      "parametros": "semantic_cube: dict[str, Any]",
      "parametros_configurables": [
        {
          "nombre": "semantic_cube",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(semantic_cube: dict[str, Any])",
      "descripcion": "Calculate semantic complexity of the cube."
    }
  },
  "SemanticAnalyzer._classify_cross_cutting_themes": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (score por categoría)",
      "formato_entrada": "segment: str",
      "formato_salida": "dict[str, float] con score por tema (governance, equity, sustainability, innovation)",
      "calculo": "cuenta keywords por tema, normaliza",
      "parametros": "segment: str",
      "parametros_configurables": [
        {
          "nombre": "segment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(segment: str)",
      "descripcion": "Classify segment by Cross-Cutting Themes / Enfoques Transversales (ET01-ET10)."
    }
  },
  "SemanticAnalyzer._classify_policy_domain": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (score por categoría)",
      "formato_entrada": "segment: str",
      "formato_salida": "dict[str, float] con score por cada policy_domain (economic, social, territorial, institutional)",
      "calculo": "cuenta keywords por dominio, normaliza por cantidad de keywords en dominio",
      "parametros": "segment: str",
      "parametros_configurables": [
        {
          "nombre": "segment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(segment: str)",
      "descripcion": "Classify segment by Policy Area (PA01-PA10) using keyword matching."
    }
  },
  "SemanticAnalyzer._classify_value_chain_link": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUANTITATIVO (score por categoría)",
      "formato_entrada": "segment: str",
      "formato_salida": "dict[str, float] con score por cada value_chain_link",
      "calculo": "cuenta keywords de instruments+mediators+outputs+outcomes en texto, normaliza por total keywords",
      "parametros": "segment: str",
      "parametros_configurables": [
        {
          "nombre": "segment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "policy_area_id",
          "anotacion": "str | None",
          "default": "None",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(segment: str, policy_area_id: str | None=None)",
      "descripcion": "Classify segment by value chain link using canonical patterns."
    }
  },
  "SemanticAnalyzer._empty_semantic_cube": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Return empty semantic cube structure.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "()"
    }
  },
  "SemanticAnalyzer._process_segment": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "segment",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "idx",
          "anotacion": "int",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "vector",
          "anotacion": null,
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(segment: str, idx: int, vector)",
      "descripcion": "Process individual segment and extract features.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(segment: str, idx: int, vector)"
    }
  },
  "SemanticAnalyzer._vectorize_segments": {
    "file": "analyzer_one.py",
    "questions": [
      "Q013"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "segments",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(segments: list[str])",
      "descripcion": "Vectorize document segments using TF-IDF.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(segments: list[str])"
    }
  },
  "SemanticAnalyzer.extract_semantic_cube": {
    "file": "analyzer_one.py",
    "questions": [
      "Q008",
      "Q023"
    ],
    "dimensions": [
      "DIM02",
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "ESTRUCTURAL (cubo multidimensional)",
      "formato_entrada": "document_segments: list[str]",
      "formato_salida": "dict con dimensions (value_chain_links, policy_domains, cross_cutting_themes) y measures (semantic_density, coherence_scores, overall_coherence)",
      "calculo": "TF-IDF vectorización → clasificación por keywords ontología → agregación por dimensión",
      "parametros": "document_segments: list[str]",
      "parametros_configurables": [
        {
          "nombre": "document_segments",
          "anotacion": "list[str]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(document_segments: list[str])",
      "descripcion": "Extract multidimensional semantic cube from document segments."
    }
  },
  "SemanticProcessor._detect_pdm_structure": {
    "file": "semantic_chunking_policy.py",
    "questions": [
      "Q030"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Detect PDM sections using Colombian policy document patterns",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "SemanticProcessor._detect_table": {
    "file": "semantic_chunking_policy.py",
    "questions": [
      "Q030"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Detect if chunk contains tabular data",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "SemanticProcessor.chunk_text": {
    "file": "semantic_chunking_policy.py",
    "questions": [
      "Q001",
      "Q030"
    ],
    "dimensions": [
      "DIM01",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "ESTRUCTURAL (segmentación)",
      "formato_entrada": "text: str, chunk_size: int, overlap: int",
      "formato_salida": "list[str] de chunks con overlap",
      "calculo": "segmenta por oraciones, agrupa hasta chunk_size, mantiene overlap",
      "parametros": "text: str, chunk_size: int=512, overlap: int=50",
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "preserve_structure",
          "anotacion": "bool",
          "default": "True",
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str, preserve_structure: bool=True)",
      "descripcion": "Policy-aware semantic chunking:"
    }
  },
  "SemanticProcessor.embed_single": {
    "file": "semantic_chunking_policy.py",
    "questions": [
      "Q001"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Single text embedding",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "TemporalLogicVerifier._check_deadline_constraints": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q005"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "timeline",
          "anotacion": "list[dict]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(timeline: list[dict])",
      "descripcion": "Verifica violaciones de restricciones de plazo",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(timeline: list[dict])"
    }
  },
  "TemporalLogicVerifier._classify_temporal_type": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "marker",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(marker: str)",
      "descripcion": "Clasifica el tipo de marcador temporal",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(marker: str)"
    }
  },
  "TemporalLogicVerifier._extract_resources": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "text",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(text: str)",
      "descripcion": "Extrae recursos mencionados en el texto",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(text: str)"
    }
  },
  "TemporalLogicVerifier._parse_temporal_marker": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q016"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "marker",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(marker: str)",
      "descripcion": "Parse temporal marker to numeric timestamp.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(marker: str)"
    }
  },
  "TemporalLogicVerifier.verify_temporal_consistency": {
    "file": "contradiction_deteccion.py",
    "questions": [
      "Q005"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO (validación)",
      "formato_entrada": "temporal_claims: list[dict] con fechas/plazos",
      "formato_salida": "list de violaciones temporales (overlap, impossible_sequence, deadline_conflict)",
      "calculo": "ordena eventos, verifica secuencia lógica, detecta conflictos de deadline",
      "parametros": "temporal_claims: list[dict]",
      "parametros_configurables": [
        {
          "nombre": "statements",
          "anotacion": "list[PolicyStatement]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(statements: list[PolicyStatement])",
      "descripcion": "Verify temporal consistency between policy statements."
    }
  },
  "TeoriaCambio._encontrar_caminos_completos": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q017"
    ],
    "dimensions": [
      "DIM04"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "grafo",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(grafo: nx.DiGraph)",
      "descripcion": "Encuentra todos los caminos simples desde nodos INSUMOS a CAUSALIDAD.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(grafo: nx.DiGraph)"
    }
  },
  "TeoriaCambio._es_conexion_valida": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q007"
    ],
    "dimensions": [
      "DIM02"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "origen",
          "anotacion": "CategoriaCausal",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "destino",
          "anotacion": "CategoriaCausal",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(origen: CategoriaCausal, destino: CategoriaCausal)",
      "descripcion": "Verifica la validez de una conexión causal según la jerarquía estructural.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(origen: CategoriaCausal, destino: CategoriaCausal)"
    }
  },
  "TeoriaCambio._extraer_categorias": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q014"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "grafo",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(grafo: nx.DiGraph)",
      "descripcion": "Extrae el conjunto de categorías presentes en el grafo.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(grafo: nx.DiGraph)"
    }
  },
  "TeoriaCambio._generar_sugerencias_internas": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q012"
    ],
    "dimensions": [
      "DIM03"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "validacion",
          "anotacion": "ValidacionResultado",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(validacion: ValidacionResultado)",
      "descripcion": "Genera un listado de sugerencias accionables basadas en los resultados.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(validacion: ValidacionResultado)"
    }
  },
  "TeoriaCambio._validar_orden_causal": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q015",
      "Q021"
    ],
    "dimensions": [
      "DIM03",
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO (validación)",
      "formato_entrada": "source_node: dict, target_node: dict",
      "formato_salida": "bool valid, str violation_reason if invalid",
      "calculo": "verifica orden jerárquico: insumo→actividad→producto→resultado→impacto",
      "parametros": "source_node: dict, target_node: dict",
      "parametros_configurables": [
        {
          "nombre": "grafo",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(grafo: nx.DiGraph)",
      "descripcion": "Identifica las aristas que violan el orden causal axiomático."
    }
  },
  "TeoriaCambio.construir_grafo_causal": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q007",
      "Q026"
    ],
    "dimensions": [
      "DIM02",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "ESTRUCTURAL (DAG)",
      "formato_entrada": "nodes: list[dict], edges: list[tuple]",
      "formato_salida": "nx.DiGraph con nodos categorizados y aristas validadas",
      "calculo": "construye grafo, valida aciclicidad, asigna categorías causales",
      "parametros": "nodes: list, edges: list",
      "parametros_configurables": [],
      "firma": "()",
      "descripcion": "Construye y cachea el grafo causal canónico."
    }
  },
  "TeoriaCambio.export_nodes": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q026"
    ],
    "dimensions": [
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [],
      "firma": "No localizada",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "No localizada"
    }
  },
  "TeoriaCambio.validacion_completa": {
    "file": "teoria_cambio.py",
    "questions": [
      "Q017",
      "Q026"
    ],
    "dimensions": [
      "DIM04",
      "DIM06"
    ],
    "operacionalizacion": {
      "parametros_configurables": [
        {
          "nombre": "grafo",
          "anotacion": "nx.DiGraph",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(grafo: nx.DiGraph)",
      "descripcion": "Ejecuta una validación estructural exhaustiva de la teoría de cambio.",
      "tipo_valor": "NO_DOCUMENTADO",
      "formato_entrada": "No documentado",
      "formato_salida": "No documentado",
      "calculo": "No documentado; revisar implementación en código.",
      "parametros": "(grafo: nx.DiGraph)"
    }
  },
  "TextMiningEngine._analyze_link_text": {
    "file": "analyzer_one.py",
    "questions": [
      "Q001",
      "Q005"
    ],
    "dimensions": [
      "DIM01"
    ],
    "operacionalizacion": {
      "tipo_valor": "PATRON + CUANTITATIVO",
      "formato_entrada": "text: str, link_config: ValueChainLink",
      "formato_salida": "análisis con instrument_coverage, mediator_coverage, bottleneck_density",
      "calculo": "cuenta matches de keywords por categoría, calcula cobertura %",
      "parametros": "text: str, link_config: ValueChainLink",
      "parametros_configurables": [
        {
          "nombre": "segments",
          "anotacion": "list[dict]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(segments: list[dict])",
      "descripcion": "Analyze text content for a link."
    }
  },
  "TextMiningEngine._generate_interventions": {
    "file": "analyzer_one.py",
    "questions": [
      "Q021"
    ],
    "dimensions": [
      "DIM05"
    ],
    "operacionalizacion": {
      "tipo_valor": "CUALITATIVO (generación texto)",
      "formato_entrada": "link_analysis: dict, link_config: ValueChainLink",
      "formato_salida": "list[str] de intervenciones sugeridas",
      "calculo": "basado en gaps identificados (low coverage, high bottleneck), genera texto de intervención",
      "parametros": "link_analysis: dict, link_config: ValueChainLink",
      "parametros_configurables": [
        {
          "nombre": "link_name",
          "anotacion": "str",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "risk_assessment",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "text_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(link_name: str, risk_assessment: dict[str, Any], text_analysis: dict[str, Any])",
      "descripcion": "Generate intervention recommendations."
    }
  },
  "TextMiningEngine.diagnose_critical_links": {
    "file": "analyzer_one.py",
    "questions": [
      "Q001",
      "Q011",
      "Q030"
    ],
    "dimensions": [
      "DIM01",
      "DIM03",
      "DIM06"
    ],
    "operacionalizacion": {
      "tipo_valor": "MIXTO (cuantitativo + cualitativo)",
      "formato_entrada": "document_text: str",
      "formato_salida": "lista de links críticos con diagnóstico (score, severity, intervention)",
      "calculo": "analiza texto por link, calcula criticality_score, genera intervenciones",
      "parametros": "document_text: str",
      "parametros_configurables": [
        {
          "nombre": "semantic_cube",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        },
        {
          "nombre": "performance_analysis",
          "anotacion": "dict[str, Any]",
          "default": null,
          "kind": "positional_or_keyword"
        }
      ],
      "firma": "(semantic_cube: dict[str, Any], performance_analysis: dict[str, Any])",
      "descripcion": "Diagnose critical value chain links."
    }
  }
}