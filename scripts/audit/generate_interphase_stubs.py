#!/usr/bin/env python3
"""
Generate .pyi Stub Files for Interphase Modules
==============================================

Generates Python stub files (.pyi) for all interphase modules to improve
IDE support, type checking, and code completion.

Author: F.A.R.F.A.N Signature Governance System
Version: 1.0.0
Date: 2026-01-23
"""

import ast
import logging
from pathlib import Path
from typing import Any

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class StubGenerator:
    """Generates .pyi stub files from Python source files."""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.phases_dir = project_root / "src" / "farfan_pipeline" / "phases"
        self.stubs_generated = 0
    
    def generate_all_stubs(self) -> int:
        """Generate stub files for all interphase modules."""
        logger.info("Starting stub file generation...")
        
        # Find all interphase Python files
        phase_dirs = sorted(self.phases_dir.glob("Phase_*"))
        
        for phase_dir in phase_dirs:
            interphase_dir = phase_dir / "interphase"
            if not interphase_dir.exists():
                continue
            
            # Process each Python file
            for py_file in interphase_dir.glob("*.py"):
                if py_file.name == "__init__.py":
                    continue
                
                self._generate_stub_for_file(py_file)
        
        logger.info(f"Generated {self.stubs_generated} stub files")
        return self.stubs_generated
    
    def _generate_stub_for_file(self, py_file: Path) -> None:
        """Generate a .pyi stub file for a Python source file."""
        try:
            with open(py_file, 'r', encoding='utf-8') as f:
                source = f.read()
            
            # Parse the source file
            tree = ast.parse(source, filename=str(py_file))
            
            # Generate stub content
            stub_content = self._generate_stub_content(tree, py_file)
            
            # Write stub file
            stub_file = py_file.with_suffix('.pyi')
            with open(stub_file, 'w', encoding='utf-8') as f:
                f.write(stub_content)
            
            self.stubs_generated += 1
            logger.info(f"Generated stub: {stub_file.relative_to(self.project_root)}")
            
        except Exception as e:
            logger.error(f"Failed to generate stub for {py_file}: {e}")
    
    def _generate_stub_content(self, tree: ast.AST, source_file: Path) -> str:
        """Generate stub file content from AST."""
        lines = []
        
        # Add header
        lines.append('"""')
        lines.append(f'Type stubs for {source_file.name}')
        lines.append('')
        lines.append('Auto-generated by stub_generator.py')
        lines.append('Do not edit manually - changes will be overwritten')
        lines.append('"""')
        lines.append('')
        
        # Extract imports
        imports = self._extract_imports(tree)
        if imports:
            lines.extend(imports)
            lines.append('')
        
        # Extract type aliases and constants
        module_level = self._extract_module_level(tree)
        if module_level:
            lines.extend(module_level)
            lines.append('')
        
        # Extract class definitions
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_stub = self._generate_class_stub(node)
                if class_stub:
                    lines.extend(class_stub)
                    lines.append('')
        
        # Extract function definitions (not in classes)
        functions = []
        for node in tree.body:
            if isinstance(node, ast.FunctionDef):
                func_stub = self._generate_function_stub(node)
                if func_stub:
                    functions.extend(func_stub)
        
        if functions:
            lines.extend(functions)
            lines.append('')
        
        # Extract __all__ if present
        all_export = self._extract_all(tree)
        if all_export:
            lines.append(all_export)
            lines.append('')
        
        return '\n'.join(lines)
    
    def _extract_imports(self, tree: ast.AST) -> list[str]:
        """Extract import statements."""
        imports = []
        for node in tree.body:
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                try:
                    import_line = ast.unparse(node)
                    imports.append(import_line)
                except Exception:
                    pass
        return imports
    
    def _extract_module_level(self, tree: ast.AST) -> list[str]:
        """Extract module-level constants and type aliases."""
        items = []
        for node in tree.body:
            if isinstance(node, ast.AnnAssign):
                # Type-annotated assignment
                try:
                    line = ast.unparse(node)
                    items.append(line)
                except Exception:
                    pass
            elif isinstance(node, ast.Assign):
                # Regular assignment - only include if it looks like a constant
                try:
                    target = node.targets[0]
                    if isinstance(target, ast.Name) and target.id.isupper():
                        line = ast.unparse(node)
                        items.append(line)
                except Exception:
                    pass
        return items
    
    def _generate_class_stub(self, node: ast.ClassDef) -> list[str]:
        """Generate stub for a class definition."""
        lines = []
        
        # Class definition with bases
        bases = ', '.join(ast.unparse(base) for base in node.bases) if node.bases else ''
        if bases:
            lines.append(f'class {node.name}({bases}):')
        else:
            lines.append(f'class {node.name}:')
        
        # Docstring
        docstring = ast.get_docstring(node)
        if docstring:
            # First line only for stub
            first_line = docstring.split('\n')[0].strip()
            lines.append(f'    """{first_line}"""')
        
        # Class body
        has_content = False
        
        # Extract class variables
        for item in node.body:
            if isinstance(item, ast.AnnAssign):
                try:
                    line = ast.unparse(item)
                    lines.append(f'    {line}')
                    has_content = True
                except Exception:
                    pass
        
        # Extract methods
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                method_stub = self._generate_function_stub(item, indent='    ')
                if method_stub:
                    lines.extend(method_stub)
                    has_content = True
        
        if not has_content:
            lines.append('    ...')
        
        return lines
    
    def _generate_function_stub(self, node: ast.FunctionDef, indent: str = '') -> list[str]:
        """Generate stub for a function/method definition."""
        lines = []
        
        # Decorators
        for decorator in node.decorator_list:
            try:
                dec_line = ast.unparse(decorator)
                lines.append(f'{indent}@{dec_line}')
            except Exception:
                pass
        
        # Function signature
        args = self._format_arguments(node.args)
        return_type = self._format_return_type(node.returns)
        
        lines.append(f'{indent}def {node.name}({args}){return_type}: ...')
        
        return lines
    
    def _format_arguments(self, args: ast.arguments) -> str:
        """Format function arguments with type annotations."""
        arg_strs = []
        
        # Regular arguments
        for arg in args.args:
            if arg.annotation:
                try:
                    ann = ast.unparse(arg.annotation)
                    arg_strs.append(f'{arg.arg}: {ann}')
                except Exception:
                    arg_strs.append(arg.arg)
            else:
                arg_strs.append(arg.arg)
        
        # *args
        if args.vararg:
            if args.vararg.annotation:
                try:
                    ann = ast.unparse(args.vararg.annotation)
                    arg_strs.append(f'*{args.vararg.arg}: {ann}')
                except Exception:
                    arg_strs.append(f'*{args.vararg.arg}')
            else:
                arg_strs.append(f'*{args.vararg.arg}')
        
        # **kwargs
        if args.kwarg:
            if args.kwarg.annotation:
                try:
                    ann = ast.unparse(args.kwarg.annotation)
                    arg_strs.append(f'**{args.kwarg.arg}: {ann}')
                except Exception:
                    arg_strs.append(f'**{args.kwarg.arg}')
            else:
                arg_strs.append(f'**{args.kwarg.arg}')
        
        return ', '.join(arg_strs)
    
    def _format_return_type(self, returns: ast.expr | None) -> str:
        """Format return type annotation."""
        if returns:
            try:
                return f' -> {ast.unparse(returns)}'
            except Exception:
                pass
        return ''
    
    def _extract_all(self, tree: ast.AST) -> str | None:
        """Extract __all__ export list."""
        for node in tree.body:
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id == '__all__':
                        try:
                            return ast.unparse(node)
                        except Exception:
                            pass
        return None


def main():
    """Main entry point."""
    project_root = Path(__file__).parent.parent.parent
    
    generator = StubGenerator(project_root)
    count = generator.generate_all_stubs()
    
    print(f"\nâœ… Generated {count} stub files")
    print("\nðŸ’¡ Stub files (.pyi) provide type information for IDEs and type checkers")
    print("   without executing the code.")
    
    return 0 if count > 0 else 1


if __name__ == "__main__":
    import sys
    sys.exit(main())
