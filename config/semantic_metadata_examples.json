{
  "description": "Representative examples of semantic metadata assignments in canonical_method_catalogue_v2.json",
  "version": "1.0.0",
  "examples": {
    "contradiction_detection": {
      "method": "PolicyContradictionDetector.detect",
      "semantic_tags": ["coherence", "evidence", "policy", "structural"],
      "output_range": null,
      "fusion_requirements": {
        "required": ["extracted_text", "question_id", "preprocessed_document"],
        "optional": ["embeddings", "previous_analysis", "config", "dependency_parse"]
      },
      "rationale": "Combines coherence checking with policy-specific structural analysis"
    },
    "causal_extraction": {
      "method": "CausalExtractor.extract_causal_hierarchy",
      "semantic_tags": ["causal", "evidence", "structural"],
      "output_range": null,
      "fusion_requirements": {
        "required": ["extracted_text", "question_id", "preprocessed_document"],
        "optional": ["embeddings", "previous_analysis", "config", "dependency_parse"]
      },
      "rationale": "Extracts causal structures with evidence-based reasoning"
    },
    "bayesian_inference": {
      "method": "BayesianMechanismInference.infer_mechanisms",
      "semantic_tags": ["causal", "evidence", "numerical"],
      "output_range": null,
      "fusion_requirements": {
        "required": ["extracted_text", "question_id", "preprocessed_document"],
        "optional": ["embeddings", "previous_analysis", "config", "dependency_parse"]
      },
      "rationale": "Probabilistic causal inference with numerical evidence weighting"
    },
    "probability_calculation": {
      "method": "AdaptivePriorCalculator.calculate_likelihood_adaptativo",
      "semantic_tags": ["causal", "evidence", "numerical"],
      "output_range": [0.0, 1.0],
      "fusion_requirements": {
        "required": ["question_id", "previous_analysis"],
        "optional": ["calibration_params", "model_weights", "config"]
      },
      "rationale": "Bayesian likelihood calculation with bounded probability output"
    },
    "temporal_verification": {
      "method": "TemporalLogicVerifier.verify_temporal_consistency",
      "semantic_tags": ["coherence", "evidence", "structural", "temporal", "textual_quality"],
      "output_range": [0, 1],
      "fusion_requirements": {
        "required": ["extracted_text", "question_id"],
        "optional": ["previous_analysis", "config"]
      },
      "rationale": "Comprehensive temporal consistency checking with 5 semantic dimensions"
    },
    "temporal_coherence": {
      "method": "CausalExtractor._assess_temporal_coherence",
      "semantic_tags": ["causal", "coherence", "evidence", "structural", "temporal"],
      "output_range": null,
      "fusion_requirements": {
        "required": ["extracted_text", "question_id", "preprocessed_document"],
        "optional": ["embeddings", "previous_analysis", "config", "dependency_parse"]
      },
      "rationale": "Most semantically rich method (5 tags) combining causal, temporal, and coherence analysis"
    },
    "scoring_method": {
      "method": "MicroQuestionScorer.score_type_a",
      "semantic_tags": ["evidence", "numerical"],
      "output_range": [0.0, 1.0],
      "fusion_requirements": {
        "required": ["extracted_text"],
        "optional": ["config"]
      },
      "rationale": "Standard scoring method with normalized output range"
    },
    "validation_method": {
      "method": "QuestionAnalysis.validate_score_bounds",
      "semantic_tags": ["evidence", "numerical", "textual_quality"],
      "output_range": [0.0, 1.0],
      "fusion_requirements": {
        "required": ["extracted_text"],
        "optional": ["config"]
      },
      "rationale": "Validation combining numerical bounds checking with quality assessment"
    },
    "count_method": {
      "method": "ReportMetadata.validate_analyzed_count",
      "semantic_tags": ["evidence", "structural", "textual_quality"],
      "output_range": [0, null],
      "fusion_requirements": {
        "required": [],
        "optional": ["config"]
      },
      "rationale": "Counting method with unbounded upper limit"
    },
    "boolean_check": {
      "method": "verify_native_dependencies",
      "semantic_tags": ["evidence", "textual_quality"],
      "output_range": [0, 1],
      "fusion_requirements": {
        "required": [],
        "optional": ["config"]
      },
      "rationale": "Binary validation with boolean-like output"
    },
    "utility_method": {
      "method": "QuestionContext.__post_init__",
      "semantic_tags": ["structural"],
      "output_range": null,
      "fusion_requirements": {
        "required": [],
        "optional": ["config"]
      },
      "rationale": "Infrastructure method with minimal dependencies"
    },
    "policy_goal_extraction": {
      "method": "CausalExtractor._extract_goals",
      "semantic_tags": ["causal", "evidence", "policy", "structural"],
      "output_range": null,
      "fusion_requirements": {
        "required": ["extracted_text", "question_id", "preprocessed_document"],
        "optional": ["embeddings", "previous_analysis", "config", "dependency_parse"]
      },
      "rationale": "Policy-specific extraction combining causal reasoning with structural analysis"
    },
    "quality_assessment": {
      "method": "ReportingEngine._calculate_quality_score",
      "semantic_tags": ["causal", "evidence", "numerical", "structural", "textual_quality"],
      "output_range": null,
      "fusion_requirements": {
        "required": ["extracted_text"],
        "optional": ["config"]
      },
      "rationale": "Holistic quality assessment with 5 semantic dimensions"
    }
  },
  "tag_combinations": {
    "most_common": [
      {
        "combination": ["structural"],
        "count": "~1000+ methods",
        "description": "Default structural methods (parsing, formatting, utilities)"
      },
      {
        "combination": ["evidence", "textual_quality"],
        "count": "~200+ methods",
        "description": "Validation and checking methods"
      },
      {
        "combination": ["causal", "evidence"],
        "count": "~150+ methods",
        "description": "Causal inference with evidence support"
      },
      {
        "combination": ["numerical", "evidence"],
        "count": "~100+ methods",
        "description": "Quantitative analysis with evidence"
      }
    ],
    "richest_classification": [
      {
        "tag_count": 5,
        "examples": [
          "CausalExtractor._assess_temporal_coherence",
          "TemporalLogicVerifier.verify_temporal_consistency",
          "PolicyContradictionDetector._calculate_coherence_metrics"
        ],
        "description": "Methods with 5 semantic dimensions representing complex multi-faceted analysis"
      }
    ]
  },
  "output_range_patterns": {
    "probabilities": {
      "range": [0.0, 1.0],
      "count": "~30 methods",
      "keywords": ["score", "probability", "confidence", "likelihood", "similarity", "weight"],
      "examples": [
        "AdaptivePriorCalculator.calculate_likelihood_adaptativo",
        "MicroQuestionScorer.score_type_a",
        "QuestionAnalysis.validate_score_bounds"
      ]
    },
    "boolean": {
      "range": [0, 1],
      "count": "~370 methods",
      "keywords": ["check", "validate", "verify", "test", "is_", "has_"],
      "examples": [
        "verify_native_dependencies",
        "RuntimeConfig._validate",
        "ReportMetadata.validate_timestamp"
      ]
    },
    "counts": {
      "range": [0, null],
      "count": "~35 methods",
      "keywords": ["count", "number", "size"],
      "examples": [
        "ReportMetadata.validate_analyzed_count",
        "BayesianCounterfactualAuditor.counterfactual_query"
      ]
    },
    "non_numeric": {
      "range": null,
      "count": "~1750 methods",
      "description": "Methods returning complex objects, text, or non-numeric values",
      "examples": [
        "CausalExtractor.extract_causal_hierarchy",
        "PolicyContradictionDetector.detect",
        "QuestionContext.__post_init__"
      ]
    }
  },
  "fusion_requirement_patterns": {
    "analysis_heavy": {
      "required_count": 3,
      "pattern": {
        "required": ["extracted_text", "question_id", "preprocessed_document"],
        "optional": ["embeddings", "previous_analysis", "config", "dependency_parse"]
      },
      "examples": [
        "PolicyContradictionDetector.detect",
        "CausalExtractor.extract_causal_hierarchy",
        "BayesianMechanismInference.infer_mechanisms"
      ],
      "description": "Full-featured analysis methods requiring rich document and question context"
    },
    "temporal_specific": {
      "required_count": 2,
      "pattern": {
        "required": ["extracted_text", "temporal_markers"],
        "optional": ["preprocessed_document", "config"]
      },
      "examples": [
        "TemporalLogicVerifier methods"
      ],
      "description": "Temporal analysis requiring time-specific markers"
    },
    "aggregation": {
      "required_count": 2,
      "pattern": {
        "required": ["question_id", "previous_analysis"],
        "optional": ["calibration_params", "model_weights", "config"]
      },
      "examples": [
        "AdaptivePriorCalculator.calculate_likelihood_adaptativo"
      ],
      "description": "Methods that aggregate or synthesize prior results"
    },
    "utility": {
      "required_count": 0,
      "pattern": {
        "required": [],
        "optional": ["config"]
      },
      "examples": [
        "QuestionContext.__post_init__",
        "RuntimeConfig._validate"
      ],
      "description": "Infrastructure and utility methods with minimal dependencies"
    }
  }
}
