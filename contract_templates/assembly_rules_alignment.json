{
  "$schema": "contract_templates_v1",
  "template_name": "assembly_rules_alignment",
  "version": "1.0.0",
  "description": "Captures Q001's perfect method→provides→sources mapping pattern for ensuring assembly rules correctly reference all method outputs",
  "derived_from": [
    "Q001.v3.json - Perfect alignment of 17 methods with assembly_rules sources",
    "Q002.v3.json - 12 methods with complete assembly coverage",
    "Q003.v3.json - 13 methods mapped to evidence graph construction",
    "Q004.v3.json - 11 methods with consolidated entity assembly"
  ],
  "core_principle": "Every method in method_binding.methods MUST appear in at least one assembly_rules[].sources entry. Every provides key MUST be referenced in assembly_rules. This ensures no method output is lost during evidence assembly.",
  "assembly_rules_schema": {
    "type": "array",
    "description": "Assembly rules define how method outputs are merged into final evidence structure",
    "items": {
      "type": "object",
      "required": ["target", "sources", "merge_strategy", "description"],
      "properties": {
        "target": {
          "type": "string",
          "description": "Target field in assembled evidence structure",
          "examples": [
            "evidence_graph",
            "relationships",
            "belief_propagation",
            "narrative_synthesis",
            "elements_found",
            "confidence_scores",
            "pattern_matches"
          ]
        },
        "sources": {
          "type": "array",
          "description": "List of method 'provides' keys or wildcard patterns that feed this target",
          "items": {"type": "string"},
          "examples": [
            [
              "text_mining.diagnose_critical_links",
              "text_mining.analyze_link_text",
              "industrial_policy.process",
              "industrial_policy.match_patterns_in_sentences"
            ],
            [
              "operationalizationauditor.audit_direct_evidence",
              "operationalizationauditor.audit_systemic_risk",
              "financial_audit.detect_allocation_gaps"
            ],
            [
              "*.confidence",
              "*.bayesian_posterior"
            ]
          ]
        },
        "merge_strategy": {
          "type": "string",
          "description": "How to combine sources into target",
          "enum": [
            "graph_construction",
            "edge_inference",
            "dempster_shafer",
            "carver_doctoral_synthesis",
            "concat",
            "weighted_mean",
            "max",
            "min",
            "union",
            "intersection"
          ],
          "examples": [
            "graph_construction",
            "concat",
            "weighted_mean"
          ]
        },
        "description": {
          "type": "string",
          "description": "Human-readable explanation of this assembly rule",
          "examples": [
            "EvidenceNexus transforms ALL 17 method outputs into EvidenceNode objects with SHA-256 hashing and builds causal evidence graph",
            "Combine all evidence elements from 12 method invocations",
            "Aggregate confidence scores across all methods"
          ]
        },
        "default": {
          "type": "any",
          "description": "Optional default value if sources are empty"
        }
      }
    }
  },
  "alignment_validation_rules": {
    "rule_1_complete_coverage": {
      "description": "Every method.provides MUST appear in at least one assembly_rules[].sources",
      "validation_query": "For each method in methods: assert exists(assembly_rule in assembly_rules where method.provides in assembly_rule.sources OR matches_wildcard(method.provides, assembly_rule.sources))",
      "violation_severity": "CRITICAL",
      "example_violation": "Method provides 'pdet_analysis.extract_financial_amounts' but no assembly_rule.sources contains it → method output will be lost"
    },
    "rule_2_no_orphan_sources": {
      "description": "Every assembly_rules[].sources entry SHOULD correspond to a method.provides (wildcards exempt)",
      "validation_query": "For each source in assembly_rules[].sources: if not is_wildcard(source): assert exists(method in methods where method.provides == source)",
      "violation_severity": "WARNING",
      "example_violation": "assembly_rule.sources contains 'text_mining.nonexistent_method' but no method provides it → assembly will fail at runtime"
    },
    "rule_3_unique_provides": {
      "description": "All method.provides keys MUST be unique (no duplicate provides)",
      "validation_query": "assert len(methods.provides) == len(set(methods.provides))",
      "violation_severity": "CRITICAL",
      "example_violation": "Two methods both provide 'financial_audit.parse_amount' → undefined behavior in assembly"
    },
    "rule_4_evidence_graph_all_methods": {
      "description": "If using EvidenceNexus (graph_construction strategy), the evidence_graph target SHOULD include ALL method provides",
      "validation_query": "If exists(rule where rule.merge_strategy == 'graph_construction'): assert len(rule.sources) == len(methods)",
      "violation_severity": "HIGH",
      "rationale": "EvidenceNexus is designed to transform all method outputs into graph nodes; partial inclusion indicates incomplete evidence assembly"
    }
  },
  "alignment_patterns": {
    "pattern_1_all_methods_to_graph": {
      "name": "All Methods to Evidence Graph",
      "description": "All method outputs feed into a single evidence_graph target with graph_construction strategy (Q001 pattern)",
      "when_to_use": "When using EvidenceNexus for graph-based evidence assembly",
      "template": {
        "target": "evidence_graph",
        "sources": [
          "/* REPLACE: List ALL method.provides keys here, one per line */",
          "method1.provides",
          "method2.provides",
          "...",
          "methodN.provides"
        ],
        "merge_strategy": "graph_construction",
        "description": "EvidenceNexus transforms ALL N method outputs into EvidenceNode objects with SHA-256 hashing and builds causal evidence graph"
      },
      "validation": "len(sources) == len(methods)",
      "example_from_q001": {
        "target": "evidence_graph",
        "sources": [
          "text_mining.diagnose_critical_links",
          "text_mining.analyze_link_text",
          "industrial_policy.process",
          "industrial_policy.match_patterns_in_sentences",
          "industrial_policy.extract_point_evidence",
          "causal_extraction.extract_goals",
          "causal_extraction.parse_goal_context",
          "financial_audit.parse_amount",
          "pdet_analysis.extract_financial_amounts",
          "pdet_analysis.extract_from_budget_table",
          "contradiction_detection.extract_quantitative_claims",
          "contradiction_detection.parse_number",
          "contradiction_detection.statistical_significance_test",
          "bayesian_analysis.evaluate_policy_metric",
          "bayesian_analysis.compare_policies",
          "semantic_processing.chunk_text",
          "semantic_processing.embed_single"
        ],
        "merge_strategy": "graph_construction",
        "description": "EvidenceNexus transforms ALL 17 method outputs into EvidenceNode objects with SHA-256 hashing and builds causal evidence graph"
      }
    },
    "pattern_2_typed_concatenation": {
      "name": "Typed Evidence Concatenation",
      "description": "Multiple methods produce similar evidence types (e.g., elements_found) that are concatenated",
      "when_to_use": "When using EvidenceAssembler with multiple evidence sources producing list-like outputs",
      "template": {
        "target": "elements_found",
        "sources": [
          "/* REPLACE: List method.provides keys for methods producing evidence elements */",
          "class1.method1",
          "class2.method2"
        ],
        "merge_strategy": "concat",
        "description": "Combine all evidence elements from N method invocations"
      },
      "example_from_q002": {
        "target": "elements_found",
        "sources": [
          "operationalizationauditor.audit_direct_evidence",
          "operationalizationauditor.audit_systemic_risk",
          "financial_audit.detect_allocation_gaps",
          "bayesianmechanisminference.detect_gaps",
          "pdet_analysis.generate_optimal_remediations",
          "pdet_analysis.simulate_intervention",
          "bayesiancounterfactualauditor.counterfactual_query",
          "bayesiancounterfactualauditor.test_effect_stability",
          "contradiction_detection.detect_numerical_inconsistencies",
          "contradiction_detection.calculate_numerical_divergence",
          "bayesianconfidencecalculator.calculate_posterior",
          "performanceanalyzer.analyze_performance"
        ],
        "merge_strategy": "concat",
        "description": "Combine all evidence elements from 12 method invocations"
      }
    },
    "pattern_3_wildcard_aggregation": {
      "name": "Wildcard Confidence Aggregation",
      "description": "Aggregate confidence scores from all methods using wildcard pattern matching",
      "when_to_use": "When all methods produce confidence scores that need aggregation",
      "template": {
        "target": "confidence_scores",
        "sources": [
          "*.confidence",
          "*.bayesian_posterior"
        ],
        "merge_strategy": "weighted_mean",
        "default": [],
        "description": "Aggregate confidence scores across all methods"
      },
      "example_from_q001": {
        "target": "belief_propagation",
        "sources": [
          "*.confidence",
          "*.bayesian_posterior"
        ],
        "merge_strategy": "dempster_shafer",
        "description": "Apply Dempster-Shafer belief propagation across graph for calibrated confidence intervals"
      }
    },
    "pattern_4_hierarchical_assembly": {
      "name": "Hierarchical Multi-Stage Assembly",
      "description": "Multiple assembly rules with dependencies: some rules depend on outputs of other rules",
      "when_to_use": "When evidence assembly has multiple stages (e.g., graph construction → edge inference → belief propagation → narrative synthesis)",
      "template": [
        {
          "target": "evidence_graph",
          "sources": ["/* all method outputs */"],
          "merge_strategy": "graph_construction",
          "description": "Stage 1: Build evidence graph from method outputs"
        },
        {
          "target": "relationships",
          "sources": ["*.causal_links", "*.supports", "*.contradicts"],
          "merge_strategy": "edge_inference",
          "description": "Stage 2: Infer edges from node properties"
        },
        {
          "target": "belief_propagation",
          "sources": ["*.confidence", "*.bayesian_posterior"],
          "merge_strategy": "dempster_shafer",
          "description": "Stage 3: Propagate beliefs across graph"
        },
        {
          "target": "narrative_synthesis",
          "sources": ["evidence_graph", "validation_report", "question_context"],
          "merge_strategy": "carver_doctoral_synthesis",
          "description": "Stage 4: Generate narrative from assembled evidence"
        }
      ],
      "example_from_q001": "See Q001.v3.json evidence_assembly.assembly_rules for 4-stage hierarchical assembly"
    }
  },
  "implementation_guidelines": {
    "step_1_enumerate_methods": {
      "description": "List all methods in method_binding.methods with their provides keys",
      "example": [
        "1. TextMiningEngine.diagnose_critical_links → text_mining.diagnose_critical_links",
        "2. TextMiningEngine._analyze_link_text → text_mining.analyze_link_text",
        "...",
        "17. SemanticProcessor.embed_single → semantic_processing.embed_single"
      ]
    },
    "step_2_design_assembly_strategy": {
      "description": "Choose assembly pattern based on evidence type and assembler",
      "decision_tree": {
        "if_using_evidence_nexus": "Use pattern_1_all_methods_to_graph",
        "if_using_evidence_assembler_with_lists": "Use pattern_2_typed_concatenation",
        "if_aggregating_confidence": "Add pattern_3_wildcard_aggregation rule",
        "if_multi_stage_processing": "Use pattern_4_hierarchical_assembly"
      }
    },
    "step_3_write_assembly_rules": {
      "description": "Create assembly_rules array with one rule per target field",
      "checklist": [
        "Create evidence_graph or elements_found rule listing ALL method provides",
        "Add confidence_scores rule with *.confidence wildcard",
        "Add pattern_matches rule if using text mining methods",
        "Add metadata rule with *.metadata wildcard for traceability",
        "Add hierarchical rules if using EvidenceNexus (relationships, belief_propagation, narrative_synthesis)"
      ]
    },
    "step_4_validate_alignment": {
      "description": "Run alignment validation checks",
      "validation_commands": [
        "Check rule_1_complete_coverage: all method.provides appear in sources",
        "Check rule_2_no_orphan_sources: all sources (non-wildcard) have corresponding methods",
        "Check rule_3_unique_provides: no duplicate provides keys",
        "Check rule_4_evidence_graph_all_methods: if graph_construction, sources == all methods"
      ]
    },
    "step_5_document_merge_strategies": {
      "description": "Ensure each rule has clear description of how merge_strategy works",
      "merge_strategy_documentation": {
        "graph_construction": "EvidenceNexus transforms method outputs into EvidenceNode objects, deduplicates via SHA-256, builds graph",
        "edge_inference": "Infer EvidenceEdge relationships (SUPPORTS, CONTRADICTS, CAUSES) between nodes",
        "dempster_shafer": "Apply Dempster-Shafer belief propagation for confidence intervals",
        "carver_doctoral_synthesis": "Generate Raymond Carver-style PhD-level narrative",
        "concat": "Concatenate lists from multiple sources",
        "weighted_mean": "Compute weighted average with method-specific weights"
      }
    }
  },
  "anti_patterns": {
    "antipattern_1_incomplete_sources": {
      "description": "Assembly rule sources list is incomplete, missing some method provides",
      "example": "17 methods defined, but evidence_graph sources only lists 15 → 2 methods' outputs lost",
      "fix": "Add missing provides keys to sources list",
      "detection": "Count methods vs. count sources in evidence_graph rule"
    },
    "antipattern_2_orphan_sources": {
      "description": "Assembly rule references provides key that doesn't exist",
      "example": "sources contains 'text_mining.nonexistent_method' but no method provides it",
      "fix": "Remove orphan source or add missing method",
      "detection": "Check each source against method provides keys"
    },
    "antipattern_3_duplicate_provides": {
      "description": "Multiple methods use same provides key",
      "example": "Method 8 and Method 10 both provide 'financial_audit.parse_amount'",
      "fix": "Make provides keys unique (e.g., 'financial_audit.parse_amount_1' and 'financial_audit.parse_amount_2')",
      "detection": "Check for duplicate values in methods[].provides"
    },
    "antipattern_4_missing_confidence_aggregation": {
      "description": "Methods produce confidence scores but no assembly rule aggregates them",
      "example": "All methods output confidence values, but no rule with sources=['*.confidence']",
      "fix": "Add confidence_scores rule with wildcard sources and weighted_mean strategy",
      "detection": "Check if any rule targets confidence-related field"
    },
    "antipattern_5_wrong_merge_strategy": {
      "description": "Merge strategy doesn't match data type (e.g., concat for scalar values, weighted_mean for lists)",
      "example": "confidence_scores rule uses concat instead of weighted_mean",
      "fix": "Choose appropriate merge_strategy for data type",
      "detection": "Review merge_strategy against target data type"
    }
  },
  "reference_examples": {
    "q001_perfect_alignment": {
      "method_count": 17,
      "assembly_rules_count": 4,
      "alignment_score": "100% (all 17 methods in evidence_graph sources)",
      "highlights": [
        "All 17 method provides keys explicitly listed in evidence_graph sources",
        "Hierarchical assembly with 4 stages: graph_construction → edge_inference → belief_propagation → narrative_synthesis",
        "Wildcard patterns for confidence (*.confidence, *.bayesian_posterior)",
        "Clear descriptions for each merge_strategy"
      ],
      "assembly_rules": [
        {
          "target": "evidence_graph",
          "sources": ["/* all 17 provides keys listed */"],
          "merge_strategy": "graph_construction"
        },
        {
          "target": "relationships",
          "sources": ["*.causal_links", "*.supports", "*.contradicts"],
          "merge_strategy": "edge_inference"
        },
        {
          "target": "belief_propagation",
          "sources": ["*.confidence", "*.bayesian_posterior"],
          "merge_strategy": "dempster_shafer"
        },
        {
          "target": "narrative_synthesis",
          "sources": ["evidence_graph", "validation_report", "question_context"],
          "merge_strategy": "carver_doctoral_synthesis"
        }
      ]
    },
    "q002_12_method_alignment": {
      "method_count": 12,
      "assembly_rules_count": 4,
      "alignment_score": "100% (all 12 methods in elements_found sources)",
      "highlights": [
        "All 12 method provides keys listed in elements_found sources",
        "Typed concatenation for elements_found, confidence_scores, pattern_matches, metadata",
        "Wildcard aggregation for confidence and metadata"
      ]
    }
  },
  "validation_tool_pseudocode": {
    "description": "Pseudocode for automated alignment validation",
    "code": [
      "def validate_assembly_alignment(contract):",
      "  methods = contract['method_binding']['methods']",
      "  assembly_rules = contract['evidence_assembly']['assembly_rules']",
      "  ",
      "  # Extract all provides keys",
      "  provides_keys = [m['provides'] for m in methods]",
      "  ",
      "  # Extract all sources (flatten and expand wildcards)",
      "  all_sources = []",
      "  for rule in assembly_rules:",
      "    all_sources.extend(rule['sources'])",
      "  ",
      "  # Check rule_1: all provides in sources",
      "  for provides in provides_keys:",
      "    if provides not in all_sources:",
      "      if not any(matches_wildcard(provides, src) for src in all_sources):",
      "        raise ValidationError(f'Method provides {provides} not in assembly sources')",
      "  ",
      "  # Check rule_2: all non-wildcard sources have methods",
      "  for source in all_sources:",
      "    if not is_wildcard(source):",
      "      if source not in provides_keys:",
      "        warn(f'Assembly source {source} has no corresponding method')",
      "  ",
      "  # Check rule_3: unique provides",
      "  if len(provides_keys) != len(set(provides_keys)):",
      "    raise ValidationError('Duplicate provides keys detected')",
      "  ",
      "  # Check rule_4: graph_construction includes all methods",
      "  graph_rules = [r for r in assembly_rules if r['merge_strategy'] == 'graph_construction']",
      "  for rule in graph_rules:",
      "    non_wildcard_sources = [s for s in rule['sources'] if not is_wildcard(s)]",
      "    if len(non_wildcard_sources) < len(methods) * 0.9:  # Allow 10% wildcards",
      "      warn(f'graph_construction rule only covers {len(non_wildcard_sources)}/{len(methods)} methods')",
      "  ",
      "  return True"
    ]
  }
}
