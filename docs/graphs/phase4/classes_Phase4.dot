digraph "classes_Phase4" {
rankdir=BT
charset="utf-8"
"Phase_04.phase4_10_00_adaptive_meso_scoring.AdaptiveMesoScoring" [color="black", fontcolor="black", label=<{AdaptiveMesoScoring|config<br ALIGN="LEFT"/>|compute_adaptive_penalty_factor(metrics: ScoringMetrics): tuple[float, dict[str, Any]]<br ALIGN="LEFT"/>compute_adjusted_score(scores: list[float], weights: list[float] \| None): tuple[float, dict[str, Any]]<br ALIGN="LEFT"/>compute_metrics(scores: list[float]): ScoringMetrics<br ALIGN="LEFT"/>get_sensitivity_analysis(scores: list[float], weights: list[float] \| None): dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_adaptive_meso_scoring.AdaptiveScoringConfig" [color="black", fontcolor="black", label=<{AdaptiveScoringConfig|base_penalty_weight : float<br ALIGN="LEFT"/>bimodal_penalty_boost : float<br ALIGN="LEFT"/>convergence_cv_threshold : float<br ALIGN="LEFT"/>convergence_di_threshold : float<br ALIGN="LEFT"/>convergence_multiplier : float<br ALIGN="LEFT"/>extreme_dispersion_cv_threshold : float<br ALIGN="LEFT"/>extreme_dispersion_multiplier : float<br ALIGN="LEFT"/>extreme_shape_factor : float<br ALIGN="LEFT"/>high_dispersion_cv_threshold : float<br ALIGN="LEFT"/>high_dispersion_multiplier : float<br ALIGN="LEFT"/>max_score : float<br ALIGN="LEFT"/>moderate_multiplier : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_provenance.AggregationDAG" [color="black", fontcolor="black", label=<{AggregationDAG|edges : list[AggregationEdge]<br ALIGN="LEFT"/>graph<br ALIGN="LEFT"/>nodes : dict[str, ProvenanceNode]<br ALIGN="LEFT"/>|add_aggregation_edge(source_ids: list[str], target_id: str, operation: str, weights: list[float], metadata: dict[str, Any] \| None): None<br ALIGN="LEFT"/>add_node(node: ProvenanceNode): None<br ALIGN="LEFT"/>compute_shapley_attribution(target_id: str): dict[str, float]<br ALIGN="LEFT"/>export_graphml(path: str): None<br ALIGN="LEFT"/>export_prov_json(path: str): None<br ALIGN="LEFT"/>get_critical_path(target_id: str, top_k: int): list[tuple[str, float]]<br ALIGN="LEFT"/>get_statistics(): dict[str, Any]<br ALIGN="LEFT"/>trace_lineage(target_id: str): dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_provenance.AggregationEdge" [color="black", fontcolor="black", label=<{AggregationEdge|metadata : dict[str, Any]<br ALIGN="LEFT"/>operation : str<br ALIGN="LEFT"/>source_id : str<br ALIGN="LEFT"/>target_id : str<br ALIGN="LEFT"/>timestamp : str<br ALIGN="LEFT"/>weight : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.AggregationError" [color="black", fontcolor="red", label=<{AggregationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_validation.AggregationValidationError" [color="black", fontcolor="red", label=<{AggregationValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.CalibrationBreakdown" [color="black", fontcolor="black", label=<{CalibrationBreakdown|interaction_contribution : float<br ALIGN="LEFT"/>linear_contribution : float<br ALIGN="LEFT"/>per_interaction_contributions : dict[tuple[str, str], float]<br ALIGN="LEFT"/>per_interaction_rationales : dict[tuple[str, str], str]<br ALIGN="LEFT"/>per_layer_contributions : dict[str, float]<br ALIGN="LEFT"/>per_layer_rationales : dict[str, str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.CalibrationConfigError" [color="black", fontcolor="red", label=<{CalibrationConfigError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.CalibrationResult" [color="black", fontcolor="black", label=<{CalibrationResult|choquet_integral_value : float<br ALIGN="LEFT"/>computational_trace : str<br ALIGN="LEFT"/>constitutional_compliance : tuple[bool, list[str]]<br ALIGN="LEFT"/>final_score : float<br ALIGN="LEFT"/>fuzzy_measure : dict[frozenset, float]<br ALIGN="LEFT"/>interaction_effects : dict[frozenset, float]<br ALIGN="LEFT"/>shapley_contributions : dict[str, float]<br ALIGN="LEFT"/>uncertainty_quantification : UncertaintyMetrics \| None<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.CalibrationResult" [color="black", fontcolor="black", label=<{CalibrationResult|breakdown<br ALIGN="LEFT"/>calibration_score : float<br ALIGN="LEFT"/>layer_scores : dict[str, float]<br ALIGN="LEFT"/>metadata : dict[str, object]<br ALIGN="LEFT"/>subject : str<br ALIGN="LEFT"/>validation_details : dict[str, object]<br ALIGN="LEFT"/>validation_passed : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.CapacityIdentificationError" [color="black", fontcolor="red", label=<{CapacityIdentificationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.ChoquetAggregator" [color="black", fontcolor="black", label=<{ChoquetAggregator|config<br ALIGN="LEFT"/>|aggregate(subject: str, layer_scores: dict[str, float], metadata: dict[str, Any] \| None): CalibrationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.ChoquetAggregator" [color="black", fontcolor="black", label=<{ChoquetAggregator|config<br ALIGN="LEFT"/>|aggregate(subject: str, layer_scores: dict[str, float], metadata: dict[str, object] \| None): CalibrationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.ChoquetConfig" [color="black", fontcolor="black", label=<{ChoquetConfig|capacity_uncertainty : UncertaintyMetrics \| None<br ALIGN="LEFT"/>constitutional_bounds : dict[str, tuple[float, float]]<br ALIGN="LEFT"/>criteria : list[str]<br ALIGN="LEFT"/>fuzzy_measure : dict[frozenset, float]<br ALIGN="LEFT"/>k_additive_order : int<br ALIGN="LEFT"/>mobius_transform : dict[frozenset, float]<br ALIGN="LEFT"/>shapley_values : dict[str, float]<br ALIGN="LEFT"/>|get_capacity(subset: set[str]): float<br ALIGN="LEFT"/>is_valid(): tuple[bool, list[str]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.ChoquetConfig" [color="black", fontcolor="black", label=<{ChoquetConfig|interaction_weights : dict[tuple[str, str], float]<br ALIGN="LEFT"/>linear_weights : dict[str, float]<br ALIGN="LEFT"/>normalize_weights : bool<br ALIGN="LEFT"/>validate_boundedness : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.ChoquetProcessingAdapter" [color="black", fontcolor="black", label=<{ChoquetProcessingAdapter|settings<br ALIGN="LEFT"/>|get_aggregator_for_macro(): ChoquetAggregator<br ALIGN="LEFT"/>process_macro_score(cluster_scores: dict[str, float], metadata: dict[str, Any] \| None): CalibrationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_integration.ClusterAggregator" [color="black", fontcolor="black", label=<{ClusterAggregator|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.ConfidenceInterval" [color="black", fontcolor="black", label=<{ConfidenceInterval|confidence_level : float<br ALIGN="LEFT"/>lower_bound : float<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>n_samples : int \| None<br ALIGN="LEFT"/>provenance : dict[str, Any]<br ALIGN="LEFT"/>upper_bound : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.CoverageError" [color="black", fontcolor="red", label=<{CoverageError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.DimensionAggregator" [color="black", fontcolor="black", label=<{DimensionAggregator|abort_on_insufficient : bool<br ALIGN="LEFT"/>aggregation_settings : AggregationSettings<br ALIGN="LEFT"/>bootstrap_aggregator : NoneType<br ALIGN="LEFT"/>dimension_group_by_keys<br ALIGN="LEFT"/>enable_sota_features : bool<br ALIGN="LEFT"/>monolith : dict[str, Any] \| None<br ALIGN="LEFT"/>niveles : NoneType<br ALIGN="LEFT"/>provenance_dag : NoneType<br ALIGN="LEFT"/>scoring_config : NoneType<br ALIGN="LEFT"/>|aggregate_dimension(scored_results: list[ScoredResult], group_by_values: dict[str, Any], weights: list[float] \| None): DimensionScore<br ALIGN="LEFT"/>aggregate_with_sota(scores: list[float], weights: list[float] \| None, method: str, compute_uncertainty: bool): tuple[float, UncertaintyMetrics \| None]<br ALIGN="LEFT"/>apply_rubric_thresholds(score: float, thresholds: dict[str, float] \| None): str<br ALIGN="LEFT"/>calculate_weighted_average(scores: list[float], weights: list[float] \| None): float<br ALIGN="LEFT"/>run(scored_results: list[ScoredResult], group_by_keys: list[str]): list[DimensionScore]<br ALIGN="LEFT"/>validate_coverage(results: list[ScoredResult], expected_count: int): tuple[bool, str]<br ALIGN="LEFT"/>validate_dimension_id(dimension_id: str): bool<br ALIGN="LEFT"/>validate_policy_area_id(area_id: str): bool<br ALIGN="LEFT"/>validate_weights(weights: list[float]): tuple[bool, str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.DimensionScore" [color="black", fontcolor="black", label=<{DimensionScore|aggregation_method : str<br ALIGN="LEFT"/>aleatoric_uncertainty : float<br ALIGN="LEFT"/>area_id : str<br ALIGN="LEFT"/>confidence_interval_95 : tuple[float, float]<br ALIGN="LEFT"/>contributing_questions : list[int \| str]<br ALIGN="LEFT"/>dimension_id : str<br ALIGN="LEFT"/>epistemic_uncertainty : float<br ALIGN="LEFT"/>provenance_node_id : str<br ALIGN="LEFT"/>quality_level : str<br ALIGN="LEFT"/>score : float<br ALIGN="LEFT"/>score_std : float<br ALIGN="LEFT"/>validation_details : dict[str, Any]<br ALIGN="LEFT"/>validation_passed : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.DispersionMetrics" [color="black", fontcolor="black", label=<{DispersionMetrics|coefficient_of_variation : float<br ALIGN="LEFT"/>dispersion_index : float<br ALIGN="LEFT"/>max_val : float<br ALIGN="LEFT"/>mean : float<br ALIGN="LEFT"/>median : float<br ALIGN="LEFT"/>min_val : float<br ALIGN="LEFT"/>q1 : float<br ALIGN="LEFT"/>q3 : float<br ALIGN="LEFT"/>quartile_coefficient : float<br ALIGN="LEFT"/>scenario : str<br ALIGN="LEFT"/>std_dev : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.EnhancedAreaAggregator" [color="black", fontcolor="black", label=<{EnhancedAreaAggregator|base : Any<br ALIGN="LEFT"/>contract : NoneType<br ALIGN="LEFT"/>enable_contracts : bool<br ALIGN="LEFT"/>|diagnose_hermeticity(actual_dimension_ids: set[str], expected_dimension_ids: set[str], area_id: str): HermeticityDiagnosis<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.EnhancedClusterAggregator" [color="black", fontcolor="black", label=<{EnhancedClusterAggregator|base : Any<br ALIGN="LEFT"/>contract : NoneType<br ALIGN="LEFT"/>enable_contracts : bool<br ALIGN="LEFT"/>|adaptive_penalty(dispersion: DispersionMetrics): float<br ALIGN="LEFT"/>compute_dispersion_metrics(scores: list[float]): DispersionMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.EnhancedDimensionAggregator" [color="black", fontcolor="black", label=<{EnhancedDimensionAggregator|base : Any<br ALIGN="LEFT"/>contract : NoneType<br ALIGN="LEFT"/>enable_contracts : bool<br ALIGN="LEFT"/>|aggregate_with_confidence(scores: list[float], weights: list[float] \| None, confidence_level: float): tuple[float, ConfidenceInterval]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.EnhancedMacroAggregator" [color="black", fontcolor="black", label=<{EnhancedMacroAggregator|base : Any<br ALIGN="LEFT"/>contract : NoneType<br ALIGN="LEFT"/>enable_contracts : bool<br ALIGN="LEFT"/>|compute_strategic_alignment(cluster_scores: list[Any], area_scores: list[Any], dimension_scores: list[Any]): StrategicAlignmentMetrics<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.FuzzyMeasureGenerator" [color="black", fontcolor="black", label=<{FuzzyMeasureGenerator|criteria<br ALIGN="LEFT"/>n<br ALIGN="LEFT"/>|generate_shapley_proportional(raw_weights: dict[str, float], constitutional_bounds: dict[str, tuple[float, float]], interaction_strength: float): ChoquetConfig<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.FuzzyMeasureViolationError" [color="black", fontcolor="red", label=<{FuzzyMeasureViolationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.HermeticityDiagnosis" [color="black", fontcolor="black", label=<{HermeticityDiagnosis|duplicate_ids : list[str]<br ALIGN="LEFT"/>extra_ids : set[str]<br ALIGN="LEFT"/>is_hermetic : bool<br ALIGN="LEFT"/>missing_ids : set[str]<br ALIGN="LEFT"/>remediation_hint : str<br ALIGN="LEFT"/>severity : str<br ALIGN="LEFT"/>validation_details : dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.HermeticityValidationError" [color="black", fontcolor="red", label=<{HermeticityValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.InteractionStructure" [color="black", fontcolor="black", label=<{InteractionStructure|interaction_indices : dict[frozenset, float]<br ALIGN="LEFT"/>mobius_transform : dict[frozenset, float]<br ALIGN="LEFT"/>order : int<br ALIGN="LEFT"/>shapley_values : dict[str, float]<br ALIGN="LEFT"/>variance_explained : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_provenance.ProvenanceNode" [color="black", fontcolor="black", label=<{ProvenanceNode|level : str<br ALIGN="LEFT"/>metadata : dict[str, Any]<br ALIGN="LEFT"/>node_id : str<br ALIGN="LEFT"/>quality_level : str<br ALIGN="LEFT"/>score : float<br ALIGN="LEFT"/>timestamp : str<br ALIGN="LEFT"/>|compute_hash(): str<br ALIGN="LEFT"/>to_dict(): dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.ScoredResult" [color="black", fontcolor="black", label=<{ScoredResult|base_slot : str<br ALIGN="LEFT"/>dimension : str<br ALIGN="LEFT"/>evidence : dict[str, Any]<br ALIGN="LEFT"/>policy_area : str<br ALIGN="LEFT"/>quality_level : str<br ALIGN="LEFT"/>question_global : int \| str<br ALIGN="LEFT"/>raw_results : dict[str, Any]<br ALIGN="LEFT"/>score : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_adaptive_meso_scoring.ScoringMetrics" [color="black", fontcolor="black", label=<{ScoringMetrics|coefficient_variation : float<br ALIGN="LEFT"/>dispersion_index : float<br ALIGN="LEFT"/>mean : float<br ALIGN="LEFT"/>normalized_std : float<br ALIGN="LEFT"/>scenario_type : str<br ALIGN="LEFT"/>shape_classification : str<br ALIGN="LEFT"/>std_dev : float<br ALIGN="LEFT"/>variance : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_signal_enriched_aggregation.SignalEnrichedAggregator" [color="black", fontcolor="black", label=<{SignalEnrichedAggregator|enable_dispersion_analysis : bool<br ALIGN="LEFT"/>enable_weight_adjustment : bool<br ALIGN="LEFT"/>signal_registry : QuestionnaireSignalRegistry \| None<br ALIGN="LEFT"/>|adjust_aggregation_weights(base_weights: dict[str, float], dimension_id: str \| None, policy_area: str \| None, cluster_id: str \| None, score_data: dict[str, float] \| None): tuple[dict[str, float], dict[str, Any]]<br ALIGN="LEFT"/>analyze_score_dispersion(scores: list[float], context: str, dimension_id: str \| None): tuple[dict[str, Any], dict[str, Any]]<br ALIGN="LEFT"/>enrich_aggregation_metadata(base_metadata: dict[str, Any], weight_adjustments: dict[str, Any], dispersion_analysis: dict[str, Any], method_selection: dict[str, Any]): dict[str, Any]<br ALIGN="LEFT"/>select_aggregation_method(scores: list[float], dispersion_metrics: dict[str, Any], context: str): tuple[str, dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_enhancements.StrategicAlignmentMetrics" [color="black", fontcolor="black", label=<{StrategicAlignmentMetrics|balance_score : float<br ALIGN="LEFT"/>cluster_coherence_mean : float<br ALIGN="LEFT"/>cluster_coherence_std : float<br ALIGN="LEFT"/>coverage_rate : float<br ALIGN="LEFT"/>pa_dim_coverage : dict[tuple[str, str], float]<br ALIGN="LEFT"/>strongest_dimensions : list[tuple[str, float]]<br ALIGN="LEFT"/>systemic_gaps : list[str]<br ALIGN="LEFT"/>weakest_dimensions : list[tuple[str, float]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.ThresholdValidationError" [color="black", fontcolor="red", label=<{ThresholdValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.ValidationError" [color="black", fontcolor="red", label=<{ValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation_validation.ValidationResult" [color="black", fontcolor="black", label=<{ValidationResult|details : dict[str, Any] \| None<br ALIGN="LEFT"/>error_message : str<br ALIGN="LEFT"/>passed : bool<br ALIGN="LEFT"/>phase : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.WeightValidationError" [color="black", fontcolor="red", label=<{WeightValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"Phase_04.phase4_10_00_aggregation.CoverageError" -> "Phase_04.phase4_10_00_aggregation.AggregationError" [arrowhead="empty", arrowtail="none"];
"Phase_04.phase4_10_00_aggregation.HermeticityValidationError" -> "Phase_04.phase4_10_00_aggregation.ValidationError" [arrowhead="empty", arrowtail="none"];
"Phase_04.phase4_10_00_aggregation.ThresholdValidationError" -> "Phase_04.phase4_10_00_aggregation.ValidationError" [arrowhead="empty", arrowtail="none"];
"Phase_04.phase4_10_00_aggregation.ValidationError" -> "Phase_04.phase4_10_00_aggregation.AggregationError" [arrowhead="empty", arrowtail="none"];
"Phase_04.phase4_10_00_aggregation.WeightValidationError" -> "Phase_04.phase4_10_00_aggregation.ValidationError" [arrowhead="empty", arrowtail="none"];
"Phase_04.phase4_10_00_adaptive_meso_scoring.AdaptiveMesoScoring" -> "Phase_04.phase4_10_00_adaptive_meso_scoring.AdaptiveScoringConfig" [arrowhead="vee", arrowtail="none", fontcolor="green", label="config", style="solid"];
"Phase_04.phase4_10_00_aggregation_provenance.AggregationDAG" -> "Phase_04.phase4_10_00_aggregation_provenance.AggregationEdge" [arrowhead="vee", arrowtail="none", fontcolor="green", label="edges", style="solid"];
"Phase_04.phase4_10_00_aggregation_provenance.AggregationDAG" -> "Phase_04.phase4_10_00_aggregation_provenance.ProvenanceNode" [arrowhead="vee", arrowtail="none", fontcolor="green", label="nodes", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.CalibrationResult" -> "Phase_04.phase4_10_00_choquet_aggregator.CalibrationBreakdown" [arrowhead="vee", arrowtail="none", fontcolor="green", label="breakdown", style="solid"];
"Phase_04.phase4_10_00_choquet_adapter.ChoquetConfig" -> "Phase_04.phase4_10_00_choquet_adapter.ChoquetAggregator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"Phase_04.phase4_10_00_choquet_aggregator.ChoquetConfig" -> "Phase_04.phase4_10_00_choquet_aggregator.ChoquetAggregator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
}
