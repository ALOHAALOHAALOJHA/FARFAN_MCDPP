#!/usr/bin/env python3
"""
Create Missing SISAS Consumers

This script creates the 9 missing consumers for the SISAS irrigation system.
Only phase7_meso_consumer currently exists.

Version: 1.0.0
Date: 2026-01-19
"""

from pathlib import Path
from datetime import datetime


CONSUMERS_TO_CREATE = {
    "phase0": {
        "phase0_assembly_consumer": {
            "description": "Assembly consumer for Phase 0 bootstrap and validation",
            "signal_types": ["STATIC_LOAD", "SIGNAL_PACK", "INITIALIZATION"],
        }
    },
    "phase1": {
        "phase1_extraction_consumer": {
            "description": "Extraction consumer for Phase 1 CPP ingestion",
            "signal_types": ["MC01", "MC02", "MC03", "MC04", "MC05", "MC06", "MC07", "MC08", "MC09", "MC10"],
        }
    },
    "phase2": {
        "phase2_enrichment_consumer": {
            "description": "Enrichment consumer for Phase 2 processing",
            "signal_types": ["PATTERN_MATCHING", "TF_IDF", "SEMANTIC_SIMILARITY"],
        }
    },
    "phase3": {
        "phase3_validation_consumer": {
            "description": "Validation consumer for Phase 3 scoring",
            "signal_types": ["NORMATIVE_LOOKUP", "COMPLIANCE_CHECK", "VALIDATION_RESULT"],
        }
    },
    "phase4": {
        "phase4_dimension_consumer": {
            "description": "Dimension aggregation consumer for Phase 4",
            "signal_types": ["DIMENSION_AGGREGATION", "D1_SCORE", "D2_SCORE", "D3_SCORE", "D4_SCORE", "D5_SCORE", "D6_SCORE"],
        }
    },
    "phase5": {
        "phase5_policy_area_consumer": {
            "description": "Policy area aggregation consumer for Phase 5",
            "signal_types": ["POLICY_AREA_AGGREGATION", "PA01_SCORE", "PA02_SCORE", "PA03_SCORE", "PA04_SCORE", "PA05_SCORE",
                           "PA06_SCORE", "PA07_SCORE", "PA08_SCORE", "PA09_SCORE", "PA10_SCORE"],
        }
    },
    "phase6": {
        "phase6_cluster_consumer": {
            "description": "Cluster aggregation consumer for Phase 6",
            "signal_types": ["CLUSTER_AGGREGATION", "CL01_SCORE", "CL02_SCORE", "CL03_SCORE", "CL04_SCORE"],
        }
    },
    "phase8": {
        "phase8_macro_consumer": {
            "description": "Macro level consumer for Phase 8 holistic scoring",
            "signal_types": ["HOLISTIC_SCORING", "MACRO_LEVEL_AGGREGATION", "FINAL_SCORE"],
        }
    },
    "phase9": {
        "phase9_report_consumer": {
            "description": "Report generation consumer for Phase 9",
            "signal_types": ["TEMPLATE_ENGINE", "REPORT_GENERATION", "FINAL_OUTPUT"],
        }
    },
}

CONSUMER_TEMPLATE = '''"""
{consumer_title} - {phase_upper}

{description}

Generated by IrrigationProtocol v1.0.0
Date: {timestamp}
"""

from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field

from ..base_consumer import BaseConsumer
from ...core.signal import Signal, SignalType


@dataclass
class {class_name}Config:
    """Configuration for {class_name}."""

    enabled_signal_types: List[str] = field(default_factory=list)
    process_signals_asynchronously: bool = False
    max_batch_size: int = 100

    def __post_init__(self):
        if not self.enabled_signal_types:
            self.enabled_signal_types = {signal_types_list}


class {class_name}(BaseConsumer):
    """
    {description}

    This consumer handles signal irrigation for {phase}.

    Signal Types:
    {signal_types_formatted}
    """

    def __init__(self, config: {class_name}Config = None):
        """
        Initialize {class_name}.

        Args:
            config: Configuration for this consumer
        """
        self.config = config or {class_name}Config()
        self.consumer_id = "{phase}_{consumer_name}"
        self.subscribed_signal_types = self.config.enabled_signal_types
        self._signal_buffer: List[Signal] = []

    def consume(self, signal: Signal) -> Optional[Dict[str, Any]]:
        """
        Consume a signal from the irrigation system.

        Args:
            signal: Signal to consume

        Returns:
            Consumption result dict or None if signal type not subscribed
        """
        if signal.signal_type not in self.subscribed_signal_types:
            return None

        # Process signal based on type
        result = self._process_signal(signal)

        return {{
            "consumer_id": self.consumer_id,
            "signal_type": signal.signal_type,
            "signal_id": signal.signal_id,
            "processed": True,
            "result": result,
        }}

    def _process_signal(self, signal: Signal) -> Dict[str, Any]:
        """
        Process signal based on its type.

        Args:
            signal: Signal to process

        Returns:
            Processing result
        """
        # Default processing - can be overridden for specific signal types
        return {{
            "timestamp": signal.timestamp,
            "payload_size": len(str(signal.payload)),
            "metadata": signal.metadata,
        }}

    def consume_batch(self, signals: List[Signal]) -> List[Dict[str, Any]]:
        """
        Consume multiple signals in batch.

        Args:
            signals: List of signals to consume

        Returns:
            List of consumption results
        """
        results = []
        for signal in signals:
            result = self.consume(signal)
            if result:
                results.append(result)
        return results

    def flush_buffer(self) -> List[Dict[str, Any]]:
        """
        Flush the internal signal buffer.

        Returns:
            List of buffered consumption results
        """
        results = []
        for signal in self._signal_buffer:
            result = self.consume(signal)
            if result:
                results.append(result)
        self._signal_buffer.clear()
        return results

    def get_consumption_contract(self) -> Dict[str, Any]:
        """
        Get the consumption contract for this consumer.

        Returns:
            Dict with contract details
        """
        return {{
            "consumer_id": self.consumer_id,
            "phase": "{phase}",
            "subscribed_signal_types": self.subscribed_signal_types,
            "required_capabilities": [
                "process_signal",
                "consume_batch",
                "flush_buffer",
            ],
            "config": {{
                "process_signals_asynchronously": self.config.process_signals_asynchronously,
                "max_batch_size": self.config.max_batch_size,
            }},
        }}

    def get_status(self) -> Dict[str, Any]:
        """
        Get current status of the consumer.

        Returns:
            Dict with status information
        """
        return {{
            "consumer_id": self.consumer_id,
            "status": "active",
            "buffer_size": len(self._signal_buffer),
            "subscribed_types": self.subscribed_signal_types,
        }}
'''


def create_consumer_file(phase: str, consumer_name: str, config: dict, base_path: Path):
    """Create a single consumer file."""
    phase_path = base_path / phase
    phase_path.mkdir(parents=True, exist_ok=True)

    consumer_file = phase_path / f"{consumer_name}.py"

    # Format template parameters
    class_name = "".join(word.capitalize() for word in consumer_name.split("_"))
    timestamp = datetime.utcnow().isoformat()

    signal_types_list = repr(config["signal_types"])
    signal_types_formatted = "\\n".join(f"    - {st}" for st in config["signal_types"])

    content = CONSUMER_TEMPLATE.format(
        consumer_title=consumer_name.replace("_", " ").title(),
        phase_upper=phase.upper(),
        description=config["description"],
        phase=phase,
        consumer_name=consumer_name,
        class_name=class_name,
        timestamp=timestamp,
        signal_types_list=signal_types_list,
        signal_types_formatted=signal_types_formatted,
    )

    consumer_file.write_text(content, encoding="utf-8")
    print(f"Created: {consumer_file}")


def main():
    """Main entry point."""
    project_root = Path(__file__).resolve().parent.parent
    sisas_path = project_root / "src/farfan_pipeline/infrastructure/irrigation_using_signals/SISAS"
    consumers_path = sisas_path / "consumers"

    print(f"Creating consumers in: {consumers_path}")
    print("=" * 80)

    created_count = 0
    for phase, consumers in CONSUMERS_TO_CREATE.items():
        for consumer_name, config in consumers.items():
            consumer_file = consumers_path / phase / f"{consumer_name}.py"

            if consumer_file.exists():
                print(f"Skipping (exists): {consumer_file}")
            else:
                create_consumer_file(phase, consumer_name, config, consumers_path)
                created_count += 1

    print("=" * 80)
    print(f"Created {created_count} consumer(s)")
    print(f"Total consumers in configuration: {len(CONSUMERS_TO_CREATE)}")


if __name__ == "__main__":
    main()
