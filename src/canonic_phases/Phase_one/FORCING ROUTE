SECCIÓN 1: PRECONDICIONES DE ENTRADA (PHASE 0 → PHASE 1)
1.1 CONTRATO DE ENTRADA: CanonicalInput
[PRE-001] | ESTRUCTURA | El objeto recibido DEBE ser instancia de CanonicalInput | isinstance(input_obj, CanonicalInput) == True | FATAL: Rechazar ejecución
[PRE-002] | CAMPO | document_id DEBE existir y ser string no vacío | isinstance(input_obj.document_id, str) and len(input_obj.document_id) > 0 | FATAL: Rechazar ejecución
[PRE-003] | CAMPO | pdf_path DEBE ser Path existente en filesystem | input_obj.pdf_path.exists() == True | FATAL: Rechazar ejecución
[PRE-004] | CAMPO | pdf_sha256 DEBE ser string hexadecimal de exactamente 64 caracteres | len(input_obj.pdf_sha256) == 64 and all(c in '0123456789abcdefABCDEF' for c in input_obj.pdf_sha256) | FATAL: Rechazar ejecución
[PRE-005] | CAMPO | questionnaire_path DEBE ser Path existente en filesystem | input_obj.questionnaire_path.exists() == True | FATAL: Rechazar ejecución
[PRE-006] | CAMPO | questionnaire_sha256 DEBE ser string hexadecimal de exactamente 64 caracteres | len(input_obj.questionnaire_sha256) == 64 and all(c in '0123456789abcdefABCDEF' for c in input_obj.questionnaire_sha256) | FATAL: Rechazar ejecución
[PRE-007] | CAMPO | validation_passed DEBE ser exactamente True (tipo bool, valor True) | input_obj.validation_passed is True and isinstance(input_obj.validation_passed, bool) | FATAL: Rechazar ejecución
[PRE-008] | HASH | Recalcular SHA256 del PDF y verificar coincidencia exacta con pdf_sha256 | hashlib.sha256(pdf_path.read_bytes()).hexdigest() == input_obj.pdf_sha256 | FATAL: Rechazar ejecución (integridad comprometida)
[PRE-009] | HASH | Recalcular SHA256 del cuestionario y verificar coincidencia exacta con questionnaire_sha256 | hashlib.sha256(questionnaire_path.read_bytes()).hexdigest() == input_obj.questionnaire_sha256 | FATAL: Rechazar ejecución (integridad comprometida)
[PRE-010] | DEPENDENCIAS | check_dependencies() DEBE retornar True | check_dependencies() == True | FATAL: Rechazar ejecución (entorno no válido)

SECCIÓN 2: SUB-FASE SP0 (LANGUAGE DETECTION)
2.1 EJECUCIÓN SP0
[EXEC-SP0-001] | INVOCACIÓN | _execute_sp0_language_detection() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP0-002] | RETORNO | DEBE retornar objeto con campo primary_language | hasattr(sp0_output, 'primary_language') == True | FATAL: Terminar pipeline
[EXEC-SP0-003] | TIPO | primary_language DEBE ser string no vacío | isinstance(sp0_output.primary_language, str) and len(sp0_output.primary_language) > 0 | FATAL: Terminar pipeline
[EXEC-SP0-004] | VALOR | primary_language DEBE ser código ISO 639-1 válido (ej: "ES", "EN") | sp0_output.primary_language in ['ES', 'EN', 'FR', 'PT', ...] | WARNING: Usar default "ES"
[EXEC-SP0-005] | TRACE | DEBE invocar self._record_subphase(0, sp0_output) | verify execution_trace contiene tupla con "SP0" | FATAL: Terminar pipeline (trazabilidad rota)

SECCIÓN 3: SUB-FASE SP1 (ADVANCED PREPROCESSING)
3.1 EJECUCIÓN SP1
[EXEC-SP1-001] | INVOCACIÓN | _execute_sp1_preprocessing() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP1-002] | RETORNO | DEBE retornar objeto PreprocessedDoc | isinstance(sp1_output, PreprocessedDoc) == True | FATAL: Terminar pipeline
[EXEC-SP1-003] | CAMPO | normalized_text DEBE existir y ser string no vacío | isinstance(sp1_output.normalized_text, str) and len(sp1_output.normalized_text) > 0 | FATAL: Terminar pipeline
[EXEC-SP1-004] | NORMALIZACIÓN | normalized_text DEBE estar normalizado en forma NFC Unicode | unicodedata.is_normalized('NFC', sp1_output.normalized_text) == True | FATAL: Terminar pipeline
[EXEC-SP1-005] | TOKENIZACIÓN | DEBE contener lista de tokens | hasattr(sp1_output, 'tokens') and isinstance(sp1_output.tokens, list) | FATAL: Terminar pipeline
[EXEC-SP1-006] | TOKENIZACIÓN | tokens NO DEBE estar vacía | len(sp1_output.tokens) > 0 | FATAL: Terminar pipeline (documento vacío)
[EXEC-SP1-007] | SEGMENTACIÓN | DEBE contener lista de oraciones | hasattr(sp1_output, 'sentences') and isinstance(sp1_output.sentences, list) | FATAL: Terminar pipeline
[EXEC-SP1-008] | SEGMENTACIÓN | sentences NO DEBE estar vacía | len(sp1_output.sentences) > 0 | FATAL: Terminar pipeline (documento vacío)
[EXEC-SP1-009] | SEGMENTACIÓN | DEBE contener lista de párrafos | hasattr(sp1_output, 'paragraphs') and isinstance(sp1_output.paragraphs, list) | FATAL: Terminar pipeline
[EXEC-SP1-010] | SEGMENTACIÓN | paragraphs NO DEBE estar vacía | len(sp1_output.paragraphs) > 0 | FATAL: Terminar pipeline (documento vacío)
[EXEC-SP1-011] | TRACE | DEBE invocar self._record_subphase(1, sp1_output) | verify execution_trace contiene tupla con "SP1" | FATAL: Terminar pipeline (trazabilidad rota)

SECCIÓN 4: SUB-FASE SP2 (STRUCTURAL ANALYSIS)
4.1 EJECUCIÓN SP2
[EXEC-SP2-001] | INVOCACIÓN | _execute_sp2_structural_analysis() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP2-002] | RETORNO | DEBE retornar objeto con estructura de secciones | hasattr(sp2_output, 'sections') == True | FATAL: Terminar pipeline
[EXEC-SP2-003] | CAMPO | sections DEBE ser lista o dict | isinstance(sp2_output.sections, (list, dict)) == True | FATAL: Terminar pipeline
[EXEC-SP2-004] | JERARQUÍA | DEBE contener información de jerarquía documental | hasattr(sp2_output, 'hierarchy') == True | FATAL: Terminar pipeline
[EXEC-SP2-005] | MAPEO | DEBE contener mapeo párrafo→sección | hasattr(sp2_output, 'paragraph_to_section') == True | FATAL: Terminar pipeline
[EXEC-SP2-006] | TRACE | DEBE invocar self._record_subphase(2, sp2_output) | verify execution_trace contiene tupla con "SP2" | FATAL: Terminar pipeline (trazabilidad rota)

SECCIÓN 4.5: SUB-FASE SP3 (KNOWLEDGE GRAPH CONSTRUCTION)
4.5.1 EJECUCIÓN SP3 - CONSTRUCCIÓN DE GRAFO DE CONOCIMIENTO
[EXEC-SP3-001] | INVOCACIÓN | _execute_sp3_knowledge_graph() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP3-002] | RETORNO | DEBE retornar objeto KnowledgeGraph | isinstance(sp3_output, KnowledgeGraph) == True | FATAL: Terminar pipeline
[EXEC-SP3-003] | CAMPO | nodes DEBE ser list[KGNode] no vacía | isinstance(sp3_output.nodes, list) and len(sp3_output.nodes) > 0 | FATAL: Terminar pipeline
[EXEC-SP3-004] | CAMPO | edges DEBE ser list[KGEdge] | isinstance(sp3_output.edges, list) == True | FATAL: Terminar pipeline
[EXEC-SP3-005] | ENTIDADES | nodes DEBE contener entidades de tipos: ACTOR, INDICADOR, TERRITORIO | all(n.type in ['ACTOR', 'INDICADOR', 'TERRITORIO', 'concept', 'policy'] for n in sp3_output.nodes) | WARNING: Cobertura de entidades incompleta
[EXEC-SP3-006] | TRACE | DEBE invocar self._record_subphase(3, sp3_output) | verify execution_trace contiene tupla con "SP3" | FATAL: Terminar pipeline (trazabilidad rota)

SECCIÓN 5: SUB-FASE SP4 (STRUCTURED PA×DIM SEGMENTATION)
5.1 EJECUCIÓN SP4 - INVARIANTE CONSTITUCIONAL CRÍTICO
[EXEC-SP4-001] | INVOCACIÓN | _execute_sp4_segmentation() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP4-002] | RETORNO | DEBE retornar lista de chunks | isinstance(sp4_output, list) == True | FATAL: Terminar pipeline
[INT-SP4-003] | CARDINALIDAD | Lista DEBE contener EXACTAMENTE 60 chunks | len(sp4_output) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-SP4-004] | TIPO | Cada elemento DEBE ser objeto Chunk o compatible | all(hasattr(c, 'chunk_id') for c in sp4_output) | FATAL: Terminar pipeline
[EXEC-SP4-005] | CHUNK_ID | Cada chunk DEBE tener chunk_id en formato PA{01-10}-DIM{01-06} | all(re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', c.chunk_id) for c in sp4_output) | FATAL: Terminar pipeline
[INT-SP4-006] | COBERTURA | DEBE cubrir TODAS las 60 combinaciones PA×DIM sin duplicados | set(c.chunk_id for c in sp4_output) == {f"PA{pa:02d}-DIM{dim:02d}" for pa in range(1,11) for dim in range(1,7)} | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-SP4-007] | CONTENIDO | Cada chunk DEBE tener campo text no vacío | all(hasattr(c, 'text') and len(c.text) > 0 for c in sp4_output) | FATAL: Terminar pipeline
[EXEC-SP4-008] | TRACE | DEBE invocar self._record_subphase(4, sp4_output) | verify execution_trace contiene tupla con "SP4" | FATAL: Terminar pipeline (trazabilidad rota)

SECCIÓN 6: SUB-FASES SP5-SP10 (ENRIQUECIMIENTO)
6.1 SP5: CAUSAL CHAIN EXTRACTION
[EXEC-SP5-001] | INVOCACIÓN | _execute_sp5_causal_extraction() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP5-002] | RETORNO | DEBE retornar objeto con causal_chains | hasattr(sp5_output, 'causal_chains') == True | FATAL: Terminar pipeline
[EXEC-SP5-003] | TIPO | causal_chains DEBE ser list o dict | isinstance(sp5_output.causal_chains, (list, dict)) == True | FATAL: Terminar pipeline
[EXEC-SP5-004] | TRACE | DEBE invocar self._record_subphase(5, sp5_output) | verify execution_trace contiene tupla con "SP5" | FATAL: Terminar pipeline
6.2 SP6: INTEGRATED CAUSAL
[EXEC-SP6-001] | INVOCACIÓN | _execute_sp6_integrated_causal() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP6-002] | RETORNO | DEBE retornar objeto con integrated_causal | hasattr(sp6_output, 'integrated_causal') == True | FATAL: Terminar pipeline
[EXEC-SP6-003] | TRACE | DEBE invocar self._record_subphase(6, sp6_output) | verify execution_trace contiene tupla con "SP6" | FATAL: Terminar pipeline
6.3 SP7: ARGUMENTATIVE ANALYSIS
[EXEC-SP7-001] | INVOCACIÓN | _execute_sp7_argumentative_analysis() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP7-002] | RETORNO | DEBE retornar objeto con argumentative_structure | hasattr(sp7_output, 'argumentative_structure') == True | FATAL: Terminar pipeline
[EXEC-SP7-003] | TRACE | DEBE invocar self._record_subphase(7, sp7_output) | verify execution_trace contiene tupla con "SP7" | FATAL: Terminar pipeline
6.4 SP8: TEMPORAL ANALYSIS
[EXEC-SP8-001] | INVOCACIÓN | _execute_sp8_temporal_analysis() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP8-002] | RETORNO | DEBE retornar objeto con temporal_markers | hasattr(sp8_output, 'temporal_markers') == True | FATAL: Terminar pipeline
[EXEC-SP8-003] | TRACE | DEBE invocar self._record_subphase(8, sp8_output) | verify execution_trace contiene tupla con "SP8" | FATAL: Terminar pipeline
6.5 SP9: DISCOURSE ANALYSIS
[EXEC-SP9-001] | INVOCACIÓN | _execute_sp9_discourse_analysis() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP9-002] | RETORNO | DEBE retornar objeto con discourse_structure | hasattr(sp9_output, 'discourse_structure') == True | FATAL: Terminar pipeline
[EXEC-SP9-003] | TRACE | DEBE invocar self._record_subphase(9, sp9_output) | verify execution_trace contiene tupla con "SP9" | FATAL: Terminar pipeline
6.6 SP10: STRATEGIC INTEGRATION
[EXEC-SP10-001] | INVOCACIÓN | _execute_sp10_strategic_integration() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP10-002] | RETORNO | DEBE retornar objeto con strategic_integration | hasattr(sp10_output, 'strategic_integration') == True | FATAL: Terminar pipeline
[EXEC-SP10-003] | TRACE | DEBE invocar self._record_subphase(10, sp10_output) | verify execution_trace contiene tupla con "SP10" | FATAL: Terminar pipeline

SECCIÓN 7: SUB-FASE SP11 (SMART CHUNK GENERATION)
7.1 EJECUCIÓN SP11 - ENRIQUECIMIENTO CRÍTICO
[EXEC-SP11-001] | INVOCACIÓN | _execute_sp11_smart_chunks() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP11-002] | RETORNO | DEBE retornar lista de SmartChunk | isinstance(sp11_output, list) == True | FATAL: Terminar pipeline
[INT-SP11-003] | CARDINALIDAD | Lista DEBE contener EXACTAMENTE 60 SmartChunks | len(sp11_output) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-SP11-004] | TIPO | Cada elemento DEBE ser SmartChunk | all(isinstance(c, SmartChunk) for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-005] | CHUNK_ID | Cada SmartChunk DEBE tener chunk_id válido | all(hasattr(c, 'chunk_id') and re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', c.chunk_id) for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-006] | METADATOS | Cada SmartChunk DEBE tener causal_graph | all(hasattr(c, 'causal_graph') for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-007] | METADATOS | Cada SmartChunk DEBE tener temporal_markers | all(hasattr(c, 'temporal_markers') for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-008] | METADATOS | Cada SmartChunk DEBE tener signal_tags | all(hasattr(c, 'signal_tags') for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-009] | METADATOS | causal_graph DEBE ser dict o compatible | all(isinstance(c.causal_graph, (dict, type(None))) for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-010] | METADATOS | temporal_markers DEBE ser list o compatible | all(isinstance(c.temporal_markers, (list, type(None))) for c in sp11_output) | FATAL: Terminar pipeline
[EXEC-SP11-011] | METADATOS | signal_tags DEBE ser list o compatible | all(isinstance(c.signal_tags, (list, type(None))) for c in sp11_output) | FATAL: Terminar pipeline
[INT-SP11-012] | COBERTURA | DEBE cubrir TODAS las 60 combinaciones PA×DIM sin duplicados | set(c.chunk_id for c in sp11_output) == {f"PA{pa:02d}-DIM{dim:02d}" for pa in range(1,11) for dim in range(1,7)} | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-SP11-013] | TRACE | DEBE invocar self._record_subphase(11, sp11_output) | verify execution_trace contiene tupla con "SP11" | FATAL: Terminar pipeline

SECCIÓN 8: SUB-FASE SP12 (INTER-CHUNK ENRICHMENT)
8.1 EJECUCIÓN SP12
[EXEC-SP12-001] | INVOCACIÓN | _execute_sp12_interchunk_enrichment() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP12-002] | RETORNO | DEBE retornar objeto con relaciones inter-chunk | hasattr(sp12_output, 'chunk_relations') == True | FATAL: Terminar pipeline
[EXEC-SP12-003] | TIPO | chunk_relations DEBE ser list o dict | isinstance(sp12_output.chunk_relations, (list, dict)) == True | FATAL: Terminar pipeline
[EXEC-SP12-004] | TRACE | DEBE invocar self._record_subphase(12, sp12_output) | verify execution_trace contiene tupla con "SP12" | FATAL: Terminar pipeline

SECCIÓN 9: SUB-FASE SP14 (DEDUPLICATION)
9.1 EJECUCIÓN SP14 - LIMPIEZA Y UNICIDAD
[EXEC-SP14-001] | INVOCACIÓN | _execute_sp14_deduplication() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP14-002] | RETORNO | DEBE retornar lista de chunks únicos | isinstance(sp14_output, list) == True | FATAL: Terminar pipeline
[INT-SP14-003] | CARDINALIDAD | Lista DEBE contener EXACTAMENTE 60 chunks | len(sp14_output) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[INT-SP14-004] | UNICIDAD | NO DEBE haber chunk_ids duplicados | len(set(c.chunk_id for c in sp14_output)) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[INT-SP14-005] | COBERTURA | DEBE cubrir TODAS las 60 combinaciones PA×DIM | set(c.chunk_id for c in sp14_output) == {f"PA{pa:02d}-DIM{dim:02d}" for pa in range(1,11) for dim in range(1,7)} | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-SP14-006] | TRACE | DEBE invocar self._record_subphase(14, sp14_output) | verify execution_trace contiene tupla con "SP14" | FATAL: Terminar pipeline

SECCIÓN 10: SUB-FASE SP15 (STRATEGIC RANKING)
10.1 EJECUCIÓN SP15
[EXEC-SP15-001] | INVOCACIÓN | _execute_sp15_strategic_ranking() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-SP15-002] | RETORNO | DEBE retornar lista de chunks con ranking | isinstance(sp15_output, list) == True | FATAL: Terminar pipeline
[INT-SP15-003] | CARDINALIDAD | Lista DEBE contener EXACTAMENTE 60 chunks | len(sp15_output) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-SP15-004] | METADATOS | Cada chunk DEBE tener strategic_rank | all(hasattr(c, 'strategic_rank') for c in sp15_output) | FATAL: Terminar pipeline
[EXEC-SP15-005] | TIPO | strategic_rank DEBE ser número (int o float) | all(isinstance(c.strategic_rank, (int, float)) for c in sp15_output) | FATAL: Terminar pipeline
[EXEC-SP15-006] | RANGO | strategic_rank DEBE estar en rango válido [0, 1] o [0, 100] según especificación | all(0 <= c.strategic_rank <= 100 for c in sp15_output) | FATAL: Terminar pipeline
[EXEC-SP15-007] | TRACE | DEBE invocar self._record_subphase(15, sp15_output) | verify execution_trace contiene tupla con "SP15" | FATAL: Terminar pipeline

SECCIÓN 11: SUB-FASE SP13 (INTEGRITY VALIDATION)
11.1 VALIDACIÓN SP13 - CHECKPOINT CRÍTICO
[VAL-SP13-001] | INVOCACIÓN | _execute_sp13_validation() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[VAL-SP13-002] | RETORNO | DEBE retornar ValidationResult | isinstance(sp13_output, ValidationResult) == True | FATAL: Terminar pipeline
[VAL-SP13-003] | STATUS | ValidationResult.status DEBE ser "VALID" | sp13_output.status == "VALID" | FATAL: Terminar pipeline
[INT-SP13-004] | CHUNK_COUNT | ValidationResult.chunk_count DEBE ser EXACTAMENTE 60 | sp13_output.chunk_count == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[VAL-SP13-005] | POLICY_AREA_ID | Cada chunk DEBE tener policy_area_id válido (PA01-PA10) | all(c.policy_area_id in [f"PA{i:02d}" for i in range(1,11)] for c in chunks) | FATAL: Terminar pipeline
[VAL-SP13-006] | DIMENSION_ID | Cada chunk DEBE tener dimension_id válido (DIM01-DIM06) | all(c.dimension_id in [f"DIM{i:02d}" for i in range(1,7)] for c in chunks) | FATAL: Terminar pipeline
[INT-SP13-007] | GRID_SPEC | PADimGridSpecification.validate_chunk() DEBE pasar para cada chunk | all(PADimGridSpecification.validate_chunk(c) == True for c in chunks) | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[INT-SP13-008] | NO_DUPLICATES | validate_chunk_set() NO DEBE detectar duplicados | validate_chunk_set(chunks) == True | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[VAL-SP13-009] | TRACE | DEBE invocar self._record_subphase(13, sp13_output) | verify execution_trace contiene tupla con "SP13" | FATAL: Terminar pipeline

SECCIÓN 12: CONSTRUCCIÓN DE CanonPolicyPackage
12.1 CPP CONSTRUCTION
[EXEC-CPP-001] | INVOCACIÓN | _construct_cpp_with_verification() DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[EXEC-CPP-002] | RETORNO | DEBE retornar CanonPolicyPackage | isinstance(cpp_output, CanonPolicyPackage) == True | FATAL: Terminar pipeline
[EXEC-CPP-003] | SCHEMA | schema_version DEBE ser "SPC-2025.1" | cpp_output.schema_version == "SPC-2025.1" | FATAL: Terminar pipeline
[EXEC-CPP-004] | DOCUMENT_ID | document_id DEBE coincidir con entrada | cpp_output.document_id == input.document_id | FATAL: Terminar pipeline
[EXEC-CPP-005] | CHUNK_GRAPH | chunk_graph DEBE existir | hasattr(cpp_output, 'chunk_graph') and cpp_output.chunk_graph is not None | FATAL: Terminar pipeline
[EXEC-CPP-006] | CHUNK_GRAPH | chunk_graph DEBE ser ChunkGraph | isinstance(cpp_output.chunk_graph, ChunkGraph) == True | FATAL: Terminar pipeline
[INT-CPP-007] | CHUNK_COUNT | chunk_graph DEBE contener EXACTAMENTE 60 chunks | len(cpp_output.chunk_graph.chunks) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[EXEC-CPP-008] | MANIFEST | policy_manifest DEBE existir | hasattr(cpp_output, 'policy_manifest') and cpp_output.policy_manifest is not None | FATAL: Terminar pipeline
[EXEC-CPP-009] | MANIFEST | policy_manifest DEBE ser PolicyManifest | isinstance(cpp_output.policy_manifest, PolicyManifest) == True | FATAL: Terminar pipeline
[EXEC-CPP-010] | QUALITY | quality_metrics DEBE existir | hasattr(cpp_output, 'quality_metrics') and cpp_output.quality_metrics is not None | FATAL: Terminar pipeline
[EXEC-CPP-011] | QUALITY | quality_metrics DEBE ser QualityMetrics | isinstance(cpp_output.quality_metrics, QualityMetrics) == True | FATAL: Terminar pipeline
[EXEC-CPP-012] | INTEGRITY | integrity_index DEBE existir | hasattr(cpp_output, 'integrity_index') and cpp_output.integrity_index is not None | FATAL: Terminar pipeline
[EXEC-CPP-013] | INTEGRITY | integrity_index DEBE ser IntegrityIndex | isinstance(cpp_output.integrity_index, IntegrityIndex) == True | FATAL: Terminar pipeline
[EXEC-CPP-014] | INTEGRITY | blake2b_root DEBE existir y ser string no vacío | hasattr(cpp_output.integrity_index, 'blake2b_root') and len(cpp_output.integrity_index.blake2b_root) > 0 | FATAL: Terminar pipeline
[EXEC-CPP-015] | METADATA | metadata DEBE existir y ser dict | hasattr(cpp_output, 'metadata') and isinstance(cpp_output.metadata, dict) | FATAL: Terminar pipeline

SECCIÓN 13: VALIDACIÓN POSTCONDICIÓN (CanonPolicyPackageValidator)
13.1 VALIDACIÓN PYDANTIC
[POST-001] | INVOCACIÓN | CanonPolicyPackageValidator.validate(cpp) DEBE ejecutarse sin excepciones | No raise ValidationError | FATAL: Terminar pipeline
[POST-002] | PROVENANCE | provenance_completeness DEBE ser >= 0.8 | cpp.quality_metrics.provenance_completeness >= 0.8 | FATAL: SLA VIOLADO - Terminar pipeline
[POST-003] | STRUCTURAL | structural_consistency DEBE ser >= 0.85 | cpp.quality_metrics.structural_consistency >= 0.85 | FATAL: SLA VIOLADO - Terminar pipeline
[INT-POST-004] | CHUNK_COUNT | chunk_count en QualityMetrics DEBE ser EXACTAMENTE 60 | cpp.quality_metrics.chunk_count == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[POST-005] | SCHEMA | schema_version DEBE ser "SPC-2025.1" | cpp.schema_version == "SPC-2025.1" | FATAL: Terminar pipeline
[POST-006] | IMMUTABILITY | CanonPolicyPackage DEBE ser frozen dataclass | cpp.__class__.__dataclass_params__.frozen == True | FATAL: Terminar pipeline

SECCIÓN 14: ADAPTADOR PHASE 1 → PHASE 2
14.1 SPCAdapter.to_preprocessed_document()
[ADAPT-001] | INVOCACIÓN | Phase1ToPhase2Adapter.adapt(cpp) DEBE ejecutarse sin excepciones | No raise Exception | FATAL: Terminar pipeline
[ADAPT-002] | RETORNO | DEBE retornar PreprocessedDocument | isinstance(adapted_output, PreprocessedDocument) == True | FATAL: Terminar pipeline
[ADAPT-003] | SENTENCES | PreprocessedDocument.sentences DEBE existir | hasattr(adapted_output, 'sentences') == True | FATAL: Terminar pipeline
[INT-ADAPT-004] | SENTENCE_COUNT | sentences DEBE contener EXACTAMENTE 60 entradas | len(adapted_output.sentences) == 60 | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline
[ADAPT-005] | EXTRA_METADATA | Cada sentence DEBE tener campo extra con metadatos | all(hasattr(s, 'extra') and isinstance(s.extra, dict) for s in adapted_output.sentences) | FATAL: Terminar pipeline
[ADAPT-006] | CHUNK_ID | Cada sentence.extra DEBE contener chunk_id | all('chunk_id' in s.extra for s in adapted_output.sentences) | FATAL: Terminar pipeline
[ADAPT-007] | POLICY_AREA | Cada sentence.extra DEBE contener policy_areaJContinuar_id | all('policy_area_id' in s.extra for s in adapted_output.sentences) | FATAL: Terminar pipeline
[ADAPT-008] | DIMENSION | Cada sentence.extra DEBE contener dimension_id | all('dimension_id' in s.extra for s in adapted_output.sentences) | FATAL: Terminar pipeline
[ADAPT-009] | CHUNK_ID_FORMAT | Cada chunk_id en extra DEBE ser formato válido PA{01-10}-DIM{01-06} | all(re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', s.extra['chunk_id']) for s in adapted_output.sentences) | FATAL: Terminar pipeline
[INT-ADAPT-010] | COBERTURA | Conjunto de chunk_ids DEBE cubrir TODAS las 60 combinaciones PA×DIM | set(s.extra['chunk_id'] for s in adapted_output.sentences) == {f"PA{pa:02d}-DIM{dim:02d}" for pa in range(1,11) for dim in range(1,7)} | FATAL: INVARIANTE CONSTITUCIONAL VIOLADO - Terminar pipeline

---

## SECCIÓN 15: TRAZABILIDAD Y LOGGING

### 15.1 EXECUTION TRACE
[TRACE-001] | ESTRUCTURA | execution_trace DEBE ser lista | isinstance(execution_trace, list) == True | FATAL: Terminar pipeline
[TRACE-002] | COMPLETITUD | execution_trace DEBE contener EXACTAMENTE 16 entradas (SP0-SP15) | len(execution_trace) == 16 | FATAL: Trazabilidad incompleta - Terminar pipeline
[TRACE-003] | FORMATO | Cada entrada DEBE ser tupla de 3 elementos (sp_label, timestamp, hash) | all(isinstance(e, tuple) and len(e) == 3 for e in execution_trace) | FATAL: Terminar pipeline
[TRACE-004] | SP_LABELS | Los labels DEBEN ser SP0, SP1, ..., SP15 en orden | [e[0] for e in execution_trace] == [f"SP{i}" for i in range(16)] | FATAL: Orden de ejecución violado - Terminar pipeline
[TRACE-005] | TIMESTAMPS | Todos los timestamps DEBEN ser strings ISO 8601 UTC | all(isinstance(e[1], str) and 'T' in e[1] and 'Z' in e[1] for e in execution_trace) | FATAL: Terminar pipeline
[TRACE-006] | HASHES | Todos los hashes DEBEN ser strings hexadecimales de 64 caracteres (SHA256) | all(isinstance(e[2], str) and len(e[2]) == 64 and all(c in '0123456789abcdef' for c in e[2]) for e in execution_trace) | FATAL: Integridad criptográfica comprometida - Terminar pipeline
[TRACE-007] | MONOTONÍA | Timestamps DEBEN ser estrictamente crecientes | all(execution_trace[i][1] < execution_trace[i+1][1] for i in range(15)) | FATAL: Orden temporal violado - Terminar pipeline

### 15.2 RUN_ID / CORRELATION_ID
[TRACE-008] | EXISTENCIA | run_id DEBE existir en metadata | 'run_id' in cpp.metadata or 'correlation_id' in cpp.metadata | FATAL: Terminar pipeline (trazabilidad rota)
[TRACE-009] | TIPO | run_id DEBE ser string no vacío | isinstance(cpp.metadata.get('run_id') or cpp.metadata.get('correlation_id'), str) and len(cpp.metadata.get('run_id') or cpp.metadata.get('correlation_id')) > 0 | FATAL: Terminar pipeline
[TRACE-010] | PROPAGACIÓN | run_id DEBE coincidir con el de entrada (Phase 0) | cpp.metadata.get('run_id') == input.metadata.get('run_id') | FATAL: Trazabilidad rota - Terminar pipeline

---

## SECCIÓN 16: MANEJO DE ERRORES Y FAILURE HANDLER

### 16.1 DETECCIÓN Y REPORTE
[ERR-001] | CAPTURA | Toda excepción en sub-fase DEBE ser capturada por try-except | verify try-except wrapper en cada _execute_spX() | FATAL: Excepción no controlada - Terminar pipeline
[ERR-002] | HANDLER | Phase1FailureHandler.handle_subphase_failure() DEBE ser invocado en caso de error | verify invocación en bloque except | FATAL: Error no registrado - Terminar pipeline
[ERR-003] | LOGGING | Error DEBE ser registrado con: sp_num, error_type, error_message | verify log contiene todos los campos | FATAL: Trazabilidad de error incompleta
[ERR-004] | MANIFEST | DEBE generarse phase1_error_manifest.json en caso de error fatal | verify archivo existe en filesystem | WARNING: Auditoría comprometida
[ERR-005] | RECOVERY | recovery_possible DEBE ser False en error fatal | error_manifest['recovery_possible'] == False | FATAL: Estado inconsistente
[ERR-006] | TERMINATION | Pipeline DEBE terminar inmediatamente tras error fatal | No código ejecutado después de Phase1FatalError | FATAL: Fail Fast violado
[ERR-007] | TIPO | Errores DEBEN ser clasificados: Phase1FatalError, ValueError, ImportError | isinstance(e, (Phase1FatalError, ValueError, ImportError)) | FATAL: Tipo de error desconocido

---

## SECCIÓN 17: INVARIANTES CONSTITUCIONALES (VERIFICACIÓN FINAL)

### 17.1 HARD INVARIANTS - PASE OBLIGATORIO
[INV-001] | CARDINALIDAD | EXACTAMENTE 60 chunks en TODAS las etapas críticas (SP4, SP11, SP14, CPP, Adapter) | all(count == 60 for count in [sp4_count, sp11_count, sp14_count, cpp_count, adapter_count]) | FATAL: INVARIANTE CONSTITUCIONAL ABSOLUTO VIOLADO - PIPELINE TERMINADO
[INV-002] | COBERTURA PA×DIM | TODAS las 60 combinaciones (PA01-PA10 × DIM01-DIM06) DEBEN estar presentes sin duplicados | verify set comprehension == 60 combinaciones únicas | FATAL: INVARIANTE CONSTITUCIONAL ABSOLUTO VIOLADO - PIPELINE TERMINADO
[INV-003] | FORMATO CHUNK_ID | TODOS los chunk_ids DEBEN ser PA{01-10}-DIM{01-06} sin excepciones | all(re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', cid) for cid in all_chunk_ids) | FATAL: INVARIANTE CONSTITUCIONAL ABSOLUTO VIOLADO - PIPELINE TERMINADO
[INV-004] | UNICIDAD | NO DEBE haber chunk_ids duplicados en ninguna etapa | len(set(chunk_ids)) == len(chunk_ids) == 60 | FATAL: INVARIANTE CONSTITUCIONAL ABSOLUTO VIOLADO - PIPELINE TERMINADO
[INV-005] | SCHEMA VERSION | schema_version DEBE ser "SPC-2025.1" en CPP | cpp.schema_version == "SPC-2025.1" | FATAL: INVARIANTE CONSTITUCIONAL ABSOLUTO VIOLADO - PIPELINE TERMINADO
[INV-006] | PROVENANCE SLA | provenance_completeness >= 0.8 | cpp.quality_metrics.provenance_completeness >= 0.8 | FATAL: SLA VIOLADO - PIPELINE TERMINADO
[INV-007] | STRUCTURAL SLA | structural_consistency >= 0.85 | cpp.quality_metrics.structural_consistency >= 0.85 | FATAL: SLA VIOLADO - PIPELINE TERMINADO
[INV-008] | INTEGRIDAD HASH | blake2b_root DEBE ser hash válido no vacío | len(cpp.integrity_index.blake2b_root) > 0 | FATAL: INTEGRIDAD CRIPTOGRÁFICA VIOLADA - PIPELINE TERMINADO
[INV-009] | TRACE COMPLETITUD | execution_trace DEBE tener EXACTAMENTE 16 entradas (SP0-SP15) | len(execution_trace) == 16 | FATAL: TRAZABILIDAD INCOMPLETA - PIPELINE TERMINADO
[INV-010] | IMMUTABILITY | CanonPolicyPackage DEBE ser inmutable (frozen dataclass) | cpp.class.dataclass_params.frozen == True | FATAL: CONTRATO DE INMUTABILIDAD VIOLADO - PIPELINE TERMINADO

---

## SECCIÓN 18: PROMPT DE IMPLEMENTACIÓN PARA DESARROLLADORES

### 18.1 PROMPT DE FORZAMIENTO DE CÓDIGO
````markdown
# IMPLEMENTACIÓN OBLIGATORIA: PHASE 1 SPC INGESTION

## CONTEXTO
Eres un ingeniero de software senior implementando la Fase 1 del pipeline SPC Ingestion.
Tu objetivo de resultado es implementar un sistema que NUNCA falle los invariantes constitucionales.

## INVARIANTES CONSTITUCIONALES (NO NEGOCIABLES)
1. **CARDINALIDAD ABSOLUTA**: En TODAS las etapas críticas (SP4, SP11, SP14, CPP, Adapter), el número de chunks DEBE ser EXACTAMENTE 60. NO 59, NO 61, EXACTAMENTE 60.
2. **COBERTURA COMPLETA**: TODAS las 60 combinaciones PA01-PA10 × DIM01-DIM06 DEBEN estar presentes sin duplicados.
3. **FORMATO ESTRICTO**: TODOS los chunk_ids DEBEN cumplir regex: ^PA(0[1-9]|10)-DIM0[1-6]$
4. **UNICIDAD**: NO puede haber chunk_ids duplicados en ninguna etapa.
5. **SLA PROVENANCE**: provenance_completeness >= 0.8 (mínimo 80%)
6. **SLA STRUCTURAL**: structural_consistency >= 0.85 (mínimo 85%)

## INSTRUCCIONES DE IMPLEMENTACIÓN

### PASO 1: Validación de Entrada
```python
def validate_input(canonical_input: CanonicalInput) -> None:
    """
    Valida entrada antes de iniciar procesamiento.
    FAIL FAST si alguna validación falla.
    """
    assert isinstance(canonical_input, CanonicalInput), "FATAL: Tipo de entrada inválido"
    assert canonical_input.validation_passed is True, "FATAL: Entrada no validada"
    assert canonical_input.pdf_path.exists(), "FATAL: PDF no existe"
    assert len(canonical_input.pdf_sha256) == 64, "FATAL: Hash SHA256 inválido"
    
    # Verificar integridad
    actual_hash = hashlib.sha256(canonical_input.pdf_path.read_bytes()).hexdigest()
    assert actual_hash == canonical_input.pdf_sha256, "FATAL: Integridad de PDF comprometida"
```

### PASO 2: Ejecución de Sub-Fases con Checkpoints
```python
def execute_subphase_with_checkpoint(
    sp_num: int,
    sp_func: Callable,
    *args,
    **kwargs
) -> Any:
    """
    Ejecuta sub-fase con checkpoint de cardinalidad.
    Registra en execution_trace.
    FAIL FAST si error.
    """
    try:
        # Ejecutar sub-fase
        output = sp_func(*args, **kwargs)
        
        # CHECKPOINT CRÍTICO: Validar cardinalidad en etapas clave
        if sp_num in [4, 11, 14]:  # SP4, SP11, SP14
            chunk_count = len(output)
            assert chunk_count == 60, f"FATAL: SP{sp_num} produjo {chunk_count} chunks, se requieren EXACTAMENTE 60"
            
            # Validar cobertura PA×DIM
            chunk_ids = {c.chunk_id for c in output}
            expected_ids = {f"PA{pa:02d}-DIM{dim:02d}" for pa in range(1,11) for dim in range(1,7)}
            assert chunk_ids == expected_ids, f"FATAL: SP{sp_num} cobertura PA×DIM incompleta"
        
        # Registrar en trace
        timestamp = datetime.utcnow().isoformat() + 'Z'
        output_hash = hashlib.sha256(json.dumps(output, default=str).encode()).hexdigest()
        self.execution_trace.append((f"SP{sp_num}", timestamp, output_hash))
        
        return output
    
    except Exception as e:
        Phase1FailureHandler.handle_subphase_failure(sp_num, e)
        raise Phase1FatalError(f"SP{sp_num} falló: {e}") from e
```

### PASO 3: Construcción de CPP con Verificación
```python
def construct_cpp_with_verification(
    chunks: List[SmartChunk],
    document_id: str,
    metadata: dict
) -> CanonPolicyPackage:
    """
    Construye CanonPolicyPackage con verificación exhaustiva.
    """
    # INVARIANTE: Verificar 60 chunks
    assert len(chunks) == 60, f"FATAL: Se recibieron {len(chunks)} chunks, se requieren EXACTAMENTE 60"
    
    # INVARIANTE: Verificar unicidad
    chunk_ids = [c.chunk_id for c in chunks]
    assert len(set(chunk_ids)) == 60, "FATAL: Chunks duplicados detectados"
    
    # INVARIANTE: Verificar formato
    for cid in chunk_ids:
        assert re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', cid), f"FATAL: chunk_id inválido: {cid}"
    
    # Construir ChunkGraph
    chunk_graph = ChunkGraph(chunks=chunks)
    
    # Construir PolicyManifest (extraer de chunks)
    policy_manifest = self._build_policy_manifest(chunks)
    
    # Calcular QualityMetrics
    quality_metrics = self._calculate_quality_metrics(chunks)
    
    # INVARIANTE: Verificar SLAs
    assert quality_metrics.provenance_completeness >= 0.8, \
        f"FATAL: provenance_completeness={quality_metrics.provenance_completeness:.2f} < 0.8"
    assert quality_metrics.structural_consistency >= 0.85, \
        f"FATAL: structural_consistency={quality_metrics.structural_consistency:.2f} < 0.85"
    
    # Calcular IntegrityIndex (blake2b root hash)
    chunk_hashes = [hashlib.blake2b(c.text.encode()).hexdigest() for c in chunks]
    blake2b_root = hashlib.blake2b(''.join(sorted(chunk_hashes)).encode()).hexdigest()
    integrity_index = IntegrityIndex(blake2b_root=blake2b_root)
    
    # Construir CPP
    cpp = CanonPolicyPackage(
        schema_version="SPC-2025.1",
        document_id=document_id,
        chunk_graph=chunk_graph,
        policy_manifest=policy_manifest,
        quality_metrics=quality_metrics,
        integrity_index=integrity_index,
        metadata=metadata
    )
    
    # VALIDACIÓN FINAL: Pydantic validator
    CanonPolicyPackageValidator.validate(cpp)
    
    return cpp
```

### PASO 4: Adaptador con Verificación
```python
def adapt_to_phase2(cpp: CanonPolicyPackage) -> PreprocessedDocument:
    """
    Adapta CPP a PreprocessedDocument para Fase 2.
    Preserva invariantes.
    """
    # INVARIANTE: Verificar entrada
    assert len(cpp.chunk_graph.chunks) == 60, "FATAL: CPP no contiene 60 chunks"
    
    # Convertir chunks a sentences
    sentences = []
    for chunk in cpp.chunk_graph.chunks:
        sentence = Sentence(
            text=chunk.text,
            extra={
                'chunk_id': chunk.chunk_id,
                'policy_area_id': chunk.policy_area_id,
                'dimension_id': chunk.dimension_id,
                'strategic_rank': chunk.strategic_rank
            }
        )
        sentences.append(sentence)
    
    # INVARIANTE: Verificar salida
    assert len(sentences) == 60, f"FATAL: Adapter produjo {len(sentences)} sentences, se requieren 60"
    
    # Verificar metadatos
    for s in sentences:
        assert 'chunk_id' in s.extra, "FATAL: sentence sin chunk_id"
        assert 'policy_area_id' in s.extra, "FATAL: sentence sin policy_area_id"
        assert 'dimension_id' in s.extra, "FATAL: sentence sin dimension_id"
        assert re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', s.extra['chunk_id']), \
            f"FATAL: chunk_id inválido: {s.extra['chunk_id']}"
    
    # Construir PreprocessedDocument
    preprocessed_doc = PreprocessedDocument(
        sentences=sentences,
        metadata={'source': 'phase1_spc_ingestion', 'cpp_schema': cpp.schema_version}
    )
    
    return preprocessed_doc
```

## REGLAS DE ORO PARA IMPLEMENTACIÓN

1. **FAIL FAST**: Ante cualquier violación de invariante, lanzar excepción inmediatamente. NO intentar "arreglar" o "aproximar".

2. **ASSERT EVERYWHERE**: Usar `assert` liberalmente en todas las etapas críticas. Mejor fallar en desarrollo que en producción.

3. **CHECKPOINT ПОСЛЕ КАЖДОЙ SUBFASE**: Después de SP4, SP11, SP14, SIEMPRE verificar:
   - Cardinalidad == 60
   - Cobertura PA×DIM completa
   - Sin duplicados
   - Formato chunk_id válido

4. **LOGGING ESTRUCTURADO**: Registrar TODOS los eventos en formato JSON:
```python
   logger.info(
       "subphase_completed",
       sp_num=sp_num,
       timestamp=timestamp,
       chunk_count=len(output),
       output_hash=output_hash
   )
```

5. **IMMUTABILITY**: Usar `@dataclass(frozen=True)` para TODAS las estructuras de datos de salida.

6. **TRACE CRIPTOGRÁFICO**: execution_trace DEBE contener hashes SHA256 de TODAS las sub-fases.

7. **VALIDACIÓN PYDANTIC**: CanonPolicyPackage DEBE tener validadores Pydantic para SLAs:
```python
   @field_validator('quality_metrics')
   @classmethod
   def validate_quality_metrics(cls, v):
       if v.provenance_completeness < 0.8:
           raise ValueError(f"provenance_completeness={v.provenance_completeness} < 0.8")
       if v.structural_consistency < 0.85:
           raise ValueError(f"structural_consistency={v.structural_consistency} < 0.85")
       return v
```

8. **ERROR MANIFEST**: En caso de error fatal, SIEMPRE generar `phase1_error_manifest.json`:
```json
   {
     "timestamp": "2025-01-15T10:30:00Z",
     "subphase": "SP4",
     "error_type": "Phase1FatalError",
     "error_message": "Cardinalidad violada: 58 chunks != 60",
     "recovery_possible": false,
     "execution_trace": [...]
   }
```

## ANTI-PATTERNS (NUNCA HACER ESTO)

❌ **NO usar try-except para "silenciar" errores de invariantes**
```python
# MAL
try:
    assert len(chunks) == 60
except AssertionError:
    logger.warning("Chunk count incorrecto, continuando...")  # ¡NO!
```

❌ **NO "aproximar" a 60 chunks**
```python
# MAL
if len(chunks) > 60:
    chunks = chunks[:60]  # ¡NO!
elif len(chunks) < 60:
    chunks.extend([dummy_chunk] * (60 - len(chunks)))  # ¡NO!
```

❌ **NO permitir chunk_ids inválidos**
```python
# MAL
if not re.match(r'^PA(0[1-9]|10)-DIM0[1-6]$', chunk_id):
    chunk_id = "PA01-DIM01"  # "arreglar" con default ¡NO!
```

❌ **NO omitir validación de cobertura PA×DIM**
```python
# MAL
# "Si hay 60 chunks, debe estar bien"  # ¡NO! Pueden ser duplicados
```

## CRITERIO DE ÉXITO

Tu implementación es EXITOSA si y solo si:
1. ✅ TODOS los tests unitarios pasan (100% cobertura de invariantes)
2. ✅ NINGÚN caso de prueba viola los invariantes constitucionales
3. ✅ execution_trace es completo (16 entradas) y válido
4. ✅ CPP generado es inmutable y cumple SLAs
5. ✅ Adapter produce PreprocessedDocument con 60 sentences válidas
6. ✅ En caso de error, pipeline termina con error manifest completo

## IMPLEMENTA AHORA

Implementa Phase1SPCIngestionFullContract siguiendo este checklist al pie de la letra.
Cada item marcado [FATAL] es un HARD STOP - si falla, el pipeline NO puede continuar.

Zero ambiguity. Zero tolerance. Fail fast, fail clean, fail deterministically.
````
