"""
Phase8 Macro Consumer - PHASE8

Macro level consumer for Phase 8 holistic scoring

Generated by IrrigationProtocol v1.0.0
Date: 2026-01-19T19:16:01.108878
"""

from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field

from ..base_consumer import BaseConsumer
from ...core.signal import Signal, SignalType


@dataclass
class Phase8MacroConsumerConfig:
    """Configuration for Phase8MacroConsumer."""

    enabled_signal_types: List[str] = field(default_factory=list)
    process_signals_asynchronously: bool = False
    max_batch_size: int = 100

    def __post_init__(self):
        if not self.enabled_signal_types:
            self.enabled_signal_types = ['HOLISTIC_SCORING', 'MACRO_LEVEL_AGGREGATION', 'FINAL_SCORE']


class Phase8MacroConsumer(BaseConsumer):
    """
    Macro level consumer for Phase 8 holistic scoring

    This consumer handles signal irrigation for phase8.

    Signal Types:
        - HOLISTIC_SCORING\n    - MACRO_LEVEL_AGGREGATION\n    - FINAL_SCORE
    """

    def __init__(self, config: Phase8MacroConsumerConfig = None):
        """
        Initialize Phase8MacroConsumer.

        Args:
            config: Configuration for this consumer
        """
        self.config = config or Phase8MacroConsumerConfig()
        self.consumer_id = "phase8_phase8_macro_consumer"
        self.subscribed_signal_types = self.config.enabled_signal_types
        self._signal_buffer: List[Signal] = []

    def consume(self, signal: Signal) -> Optional[Dict[str, Any]]:
        """
        Consume a signal from the irrigation system.

        Args:
            signal: Signal to consume

        Returns:
            Consumption result dict or None if signal type not subscribed
        """
        if signal.signal_type not in self.subscribed_signal_types:
            return None

        # Process signal based on type
        result = self._process_signal(signal)

        return {
            "consumer_id": self.consumer_id,
            "signal_type": signal.signal_type,
            "signal_id": signal.signal_id,
            "processed": True,
            "result": result,
        }

    def _process_signal(self, signal: Signal) -> Dict[str, Any]:
        """
        Process signal based on its type.

        Args:
            signal: Signal to process

        Returns:
            Processing result
        """
        # Default processing - can be overridden for specific signal types
        return {
            "timestamp": signal.timestamp,
            "payload_size": len(str(signal.payload)),
            "metadata": signal.metadata,
        }

    def consume_batch(self, signals: List[Signal]) -> List[Dict[str, Any]]:
        """
        Consume multiple signals in batch.

        Args:
            signals: List of signals to consume

        Returns:
            List of consumption results
        """
        results = []
        for signal in signals:
            result = self.consume(signal)
            if result:
                results.append(result)
        return results

    def flush_buffer(self) -> List[Dict[str, Any]]:
        """
        Flush the internal signal buffer.

        Returns:
            List of buffered consumption results
        """
        results = []
        for signal in self._signal_buffer:
            result = self.consume(signal)
            if result:
                results.append(result)
        self._signal_buffer.clear()
        return results

    def get_consumption_contract(self) -> Dict[str, Any]:
        """
        Get the consumption contract for this consumer.

        Returns:
            Dict with contract details
        """
        return {
            "consumer_id": self.consumer_id,
            "phase": "phase8",
            "subscribed_signal_types": self.subscribed_signal_types,
            "required_capabilities": [
                "process_signal",
                "consume_batch",
                "flush_buffer",
            ],
            "config": {
                "process_signals_asynchronously": self.config.process_signals_asynchronously,
                "max_batch_size": self.config.max_batch_size,
            },
        }

    def get_status(self) -> Dict[str, Any]:
        """
        Get current status of the consumer.

        Returns:
            Dict with status information
        """
        return {
            "consumer_id": self.consumer_id,
            "status": "active",
            "buffer_size": len(self._signal_buffer),
            "subscribed_types": self.subscribed_signal_types,
        }
