"""
Phase4 Dimension Consumer - PHASE4

Dimension aggregation consumer for Phase 4

Generated by IrrigationProtocol v1.0.0
Date: 2026-01-19T19:16:01.108219
"""

from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field

from ..base_consumer import BaseConsumer
from ...core.signal import Signal, SignalType


@dataclass
class Phase4DimensionConsumerConfig:
    """Configuration for Phase4DimensionConsumer."""

    enabled_signal_types: List[str] = field(default_factory=list)
    process_signals_asynchronously: bool = False
    max_batch_size: int = 100

    def __post_init__(self):
        if not self.enabled_signal_types:
            self.enabled_signal_types = ['DIMENSION_AGGREGATION', 'D1_SCORE', 'D2_SCORE', 'D3_SCORE', 'D4_SCORE', 'D5_SCORE', 'D6_SCORE']


class Phase4DimensionConsumer(BaseConsumer):
    """
    Dimension aggregation consumer for Phase 4

    This consumer handles signal irrigation for phase4.

    Signal Types:
        - DIMENSION_AGGREGATION\n    - D1_SCORE\n    - D2_SCORE\n    - D3_SCORE\n    - D4_SCORE\n    - D5_SCORE\n    - D6_SCORE
    """

    def __init__(self, config: Phase4DimensionConsumerConfig = None):
        """
        Initialize Phase4DimensionConsumer.

        Args:
            config: Configuration for this consumer
        """
        self.config = config or Phase4DimensionConsumerConfig()
        self.consumer_id = "phase4_phase4_dimension_consumer"
        self.subscribed_signal_types = self.config.enabled_signal_types
        self._signal_buffer: List[Signal] = []

    def consume(self, signal: Signal) -> Optional[Dict[str, Any]]:
        """
        Consume a signal from the irrigation system.

        Args:
            signal: Signal to consume

        Returns:
            Consumption result dict or None if signal type not subscribed
        """
        if signal.signal_type not in self.subscribed_signal_types:
            return None

        # Process signal based on type
        result = self._process_signal(signal)

        return {
            "consumer_id": self.consumer_id,
            "signal_type": signal.signal_type,
            "signal_id": signal.signal_id,
            "processed": True,
            "result": result,
        }

    def _process_signal(self, signal: Signal) -> Dict[str, Any]:
        """
        Process signal based on its type.

        Args:
            signal: Signal to process

        Returns:
            Processing result
        """
        # Default processing - can be overridden for specific signal types
        return {
            "timestamp": signal.timestamp,
            "payload_size": len(str(signal.payload)),
            "metadata": signal.metadata,
        }

    def consume_batch(self, signals: List[Signal]) -> List[Dict[str, Any]]:
        """
        Consume multiple signals in batch.

        Args:
            signals: List of signals to consume

        Returns:
            List of consumption results
        """
        results = []
        for signal in signals:
            result = self.consume(signal)
            if result:
                results.append(result)
        return results

    def flush_buffer(self) -> List[Dict[str, Any]]:
        """
        Flush the internal signal buffer.

        Returns:
            List of buffered consumption results
        """
        results = []
        for signal in self._signal_buffer:
            result = self.consume(signal)
            if result:
                results.append(result)
        self._signal_buffer.clear()
        return results

    def get_consumption_contract(self) -> Dict[str, Any]:
        """
        Get the consumption contract for this consumer.

        Returns:
            Dict with contract details
        """
        return {
            "consumer_id": self.consumer_id,
            "phase": "phase4",
            "subscribed_signal_types": self.subscribed_signal_types,
            "required_capabilities": [
                "process_signal",
                "consume_batch",
                "flush_buffer",
            ],
            "config": {
                "process_signals_asynchronously": self.config.process_signals_asynchronously,
                "max_batch_size": self.config.max_batch_size,
            },
        }

    def get_status(self) -> Dict[str, Any]:
        """
        Get current status of the consumer.

        Returns:
            Dict with status information
        """
        return {
            "consumer_id": self.consumer_id,
            "status": "active",
            "buffer_size": len(self._signal_buffer),
            "subscribed_types": self.subscribed_signal_types,
        }
